DeclareClass Name=Sound
DeclareClass Name=Player
DeclareClass Name=Script
DeclareClass Name=Pawn
DeclareClass Name=Object
DeclareClass Name=Class
DeclareClass Name=Camera
DeclareClass Name=Inventory
DeclareClass Name=Projectile
DeclareClass Name=StatusInfo
DeclareClass Name=Weapon
DeclareClass Name=EightBall
DeclareClass Name=Human
DeclareClass Name=PlayerStart
DeclareClass Name=BruteProjectile
DeclareClass Name=SkaarjProjectile
DeclareClass Name=Brute
DeclareClass Name=Gasbag
DeclareClass Name=Manta
DeclareClass Name=Tentacle
DeclareClass Name=Scout
DeclareClass Name=View
DeclareClass Name=CreaturePoint
DeclareClass Name=ArchAngel
DeclareClass Name=AutoMag
DeclareClass Name=Stinger
DeclareClass Name=Patrolpoint
DeclareClass Name=Ambushpoint
DeclareClass Name=HomeBase
DeclareClass Name=Armor
DeclareClass Name=KraalBolt
DeclareClass Name=Rock3
DeclareClass Name=Rock1
DeclareClass Name=ScriptedPawn
DeclareClass Name=WayBeacon
DeclareClass Name=BloodSpurt
DeclareClass Name=RazorFish
DeclareClass Name=Krall
DeclareClass Name=Titan
DeclareClass Name=Cow
DeclareClass Name=Pupae
DeclareClass Name=Mercenary
DeclareClass Name=Queen
DeclareClass Name=Squid
DeclareClass Name=Slith
DeclareClass Name=Warlord
DeclareClass Name=Nali
DeclareClass Name=Turret
DeclareClass Name=Hawk
DeclareClass Name=Fly
DeclareClass Name=Blob
DeclareClass Name=Firefly
DeclareClass Name=FireflySwarm
DeclareClass Name=SkaarjWarrior
DeclareClass Name=Male
DeclareClass Name=Female
DeclareClass Name=SkaarjDummy
DeclareClass Name=RazorJack
DeclareClass Name=FlakCannon

Begin Class Name=Pawn
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Pawn, the base class of all actors that can be controlled by players or AI.
// This is a built-in Unreal class and it shouldn't be modified.
// Note that Pawns which implement functions for the Tick and PlayerTick messages
// must handle player control and player/pawn physics in these functions
// this can either be done with scripting, or by calling the intrinsic
// controlplayer() and standardphysics() methods.
// these are called automatically if there is no script implementation of the Tick
// and PlayerTick messages
//=============================================================================
class Pawn expands Actor 
	abstract
	intrinsic
	package(UnEngine);

//-----------------------------------------------------------------------------
// Pawn variables

// Player info.
var const camera Camera;        // Camera, if under local player control.
var const player Player;        // Player, if controlled by a player.
var string[32]   PlayerName;    // Player name, or blank if none.
var string[32]   Team;      // Player Team, or blank if none. - note that creature team's specified by their tag
var StatusInfo   StatusBar;     // Status bar actor.
var Weapon       Weapon;        // The pawn's current weapon.
var Armor		 Armor;			// active armor
//var Powerup		 Powerup;		// active boots/powerup

// Movement.
var rotation     ViewRotation;  // View rotation.
var(Movement) int	MaxPitch; //maximum pitch/roll (0 to 65536)
var() float      BaseEyeHeight; // Base eye height above collision center.
var float        EyeHeight;     // Current eye height, adjusted for bobbing and stairs.
var(Movement) float     Bob;           // How much to bob the view.

// Camera status.
var float        OrthoZoom;     // Orthogonal/map view zoom factor.
var() float        FovAngle;      // X field of view angle in degrees, usually 90.
var int          ShowFlags;     // Camera flags.       (internal engine use)
var int          RendMap;       // Map rendering type. (internal engine use)
var int          Misc1;         // Miscellaneous.      (internal engine use)
var int          Misc2;         // Miscellaneous.      (internal engine use)

//OLD Player game statistics.
var byte DieCount, ItemCount, KillCount, SecretCount;
var float		score;

//Health
var() byte      Health;          // Health: 100 = normal maximum

// Inherent Armor.
var() enum	eArmorClass
{
ARMOR_None,
ARMOR_Normal,
ARMOR_Super,					//Normal armor types
ARMOR_God
//special armor types (damage type related) = NormalArmor for non-damage type, SuperArmor+1 for damagetype
} ArmorClass; 				//inherent armor class (effectiveness)

// General flags.
var() bool       bCanPossess;     // Players can possess this pawn.
var bool         bLocalMovement;  // Client side movement prediction in netgames.
var bool         bLocalRotation;  // Client side rotation prediction in netgames.
var bool         bBehindView;     // Outside-the-player view.
var bool          bIsPlayer;       // Pawn is a player or a player-bot.
var() bool 		bLookUpStairs;		// look up/down stairs (player)
var bool		bJustLanded;		// used by eyeheight adjustment

//AI flags
var 	bool 		bFromWall;
var	 	bool   		bReadyToAttack;		// can attack again 
var(AI) bool		bHasRangedAttack;	// can attack from beyond melee range
var(AI) bool		bMovingRangedAttack; //can perform ranged attack while moving
var(AI) bool		bCanStrafe;
var(AI) bool		bFixedStart;
var const bool		bReducedSpeed;		//used by movement intrinsices
var(Movement) bool		bCanJump;
var(Movement) bool 		bCanWalk;
var(Movement) bool		bCanSwim;
var(Movement) bool		bCanFly;
var(Movement) bool		bCanOpenDoors;
var(Movement) bool		bCanDoSpecial;

// AI basics.
var(AI) float      SightRadius;     //Maximum seeing distance.
var(AI) float      PeripheralVision;//Cosine of limits of peripheral vision.
var()	float      Noise;           //The amount of noise being made by the pawn.
var(AI) float	   HearingThreshold;  //Minimum noise loudness for hearing
var(AI) name		Orders;			//orders a creature is carrying out 
									// will be initial state, plus creature will attenmpt
									//to return to this state
var(AI) name		OrderTag;		// tag of object referred to by orders
var		actor		OrderObject;		// object referred to by orders (if applicable)
var		vector		LastSeenPos; 		// position where I last saw enemy (auto updated)
var(AI) float		TimeBetweenAttacks;  // seconds - modified by difficulty
var(AI) float	MeleeRange; // Max range for melee attack (not including collision radii)
var		float		Alertness; //-1 to 1 ->Used within specific states for varying reaction to stimuli 
var 	name		NextAnim; // used in states with multiple, sequenced animations	
var		float		SightCounter;	//Used to keep track of when to check player visibility
var		float 		Stimulus; //Strenght of stimulus - Set when stimulus happens, used in Acquisition state 
var(AI) Pawn    	Enemy;
var(AI) float		Aggressiveness; //-1.0 to 1.0 (typically) 
var() float		MoveTimer;
var(AI) Pawn		Hated;
var(AI) byte       Visibility;      //How visible is the pawn? 0 = invisible. 
									// 128 = normal.  255 = highly visible.

var(AI) enum EAttitude  //important - order in decreasing importance
{
	ATTITUDE_Fear,		//will try to run away
	ATTITUDE_Hate,		// will attack enemy
	ATTITUDE_Frenzy,	//will attack anything, indiscriminately
	ATTITUDE_Threaten,	// animations, but no attack
	ATTITUDE_Ignore,
	ATTITUDE_Friendly,
	ATTITUDE_Follow 	//accepts player as leader
} AttitudeToPlayer;	//determines how creature will react on seeing player (if in human form)

static(AI) enum EIntelligence //important - order in increasing intelligence
{
	BRAINS_NONE, //ameoba like - only reacts to immediate stimulus
	BRAINS_REPTILE, //follows to last seen position
	BRAINS_MAMMAL, //simple navigation (limited path length)
	BRAINS_HUMAN   //complex navigation, team coordination, use environment stuff (triggers, etc.)
}	Intelligence;

	
var   	Pawn		OldEnemy;
var 	Actor		MoveTarget;		//set by movement intrinsics
var		vector	 	Destination;	// set by Movement intrinsics
var	 	vector		Focus;			// set by Movement intrinsics
var		float		DesiredSpeed;

// Player and enemy movement.
var(Movement) float      GroundSpeed;     // The maximum ground speed.
var(Movement) float      WaterSpeed;      // The maximum swimming speed.
var(Movement) float      AirSpeed;        // The maximum flying speed.
var(Movement) float		 AccelRate;		  // max acceleration rate
var(Movement) float		 JumpZ;      		// vertical acceleration w/ jump
var(Movement) float      MaxStepHeight;   // Maximum size of upward/downward step.

// Input buttons.
var bool 
	bZoom, bRun, bLook, bDuck,
	bStrafe, bFire, bAltFire, bJump,
	bExtra3, bExtra2, bExtra1, bExtra0;

// Input axes.
var float 
	aForward, aTurn, aStrafe, aUp, 
	aLookUp, aExtra4, aExtra3, aExtra2,
	aExtra1, aExtra0;

// Force feedback.
var enum ESurfaceForceType
{
	SFT_None,				    // No surface forces.
	SFT_CalmWater,			    // Swimming through calm water.
	SFT_TurbulentWater,         // Swimming through turbulent water.
} SurfaceForceType;
var byte SurfaceForcePeriod;    // Period of surface force, +128 means velocity-scaled.
var byte SurfaceForceMagnitude; // Magnitude of surface force.

// PlayForce function parameter.
enum EPlayForceType
{
	PFT_Full,		// Play force at full impulse for the entire time.
	PFT_RampUp,		// Ramp force up then go away.
	PFT_RampDown,   // Start full-on then ramp force down.
	PFT_Smooth,     // Smoothly ramp force up then down.
	PFT_Decay,      // Decay exponentially.
	PFT_Instant,    // Apply for shortest instant possible.
};

var float count; //used as temp counter - note that player uses this for shaking view
var(AI) float CombatStyle; // -1 to 1 = low means tends to stay off and snipe, high means tends to charge and melee
var HomeBase home; //set when begin play, used for retreating and attitude checks
 
var name NextState; //for queueing states
var name NextLabel; //for queueing states

// Latent Movement.
//Note that MoveTo sets the actor's Destination, and MoveToward sets the
//actor's MoveTarget.  Actor will rotate towards destination

intrinsic(500) final latent function MoveTo( vector NewDestination, optional float speed);
intrinsic(502) final latent function MoveToward(actor NewTarget, optional float speed);
intrinsic(504) final latent function StrafeTo(vector NewDestination, vector NewFocus);
intrinsic(506) final latent function StrafeFacing(vector NewDestination, actor NewTarget);
intrinsic(508) final latent function TurnTo(vector NewFocus);
intrinsic(510) final latent function TurnToward(actor NewTarget);

// Intrinsic AI functions
//LineOfSightTo() returns true if any of several points of Other is visible 
// (origin, top, bottom)
intrinsic(514) final function bool LineOfSightTo(actor Other); //FIXME - move to actor
intrinsic(518) final function CreaturePoint FindPathTo(vector aPoint, optional int maxpaths, 
												optional float maxweight, optional bool bClearPaths);
intrinsic(517) final function CreaturePoint FindPathToward(actor anActor, optional int maxpaths, 
												optional float maxweight, optional bool bClearPaths);
intrinsic(525) final function CreaturePoint FindRandomDest(optional int maxpaths, 
												optional float maxweight, optional bool bClearPaths);

intrinsic(522) final function ClearPaths();
intrinsic(523) final function vector JumpLanding();

//FloorZ() returns the floor height below the point (for a given actor's collision)
intrinsic(516) final function float FloorZ(vector point);

//Reachable returns what part of direct path from Actor to aPoint is traversable
//using the current locomotion method
intrinsic(521) final function bool pointReachable(vector aPoint);
intrinsic(520) final function bool actorReachable(actor anActor);

//FIXME - CanSee redundant?

// Intrinsic force feedback functions.
intrinsic(295) final function PlayForce( EPlayForceType Type, vector Force, float Time );

#exec AUDIO IMPORT FILE="..\Sounds\Player\fyell1.UFX" NAME="FYell1" FAMILY="Player"
#exec AUDIO IMPORT FILE="..\Sounds\Player\fgrunt2.UFX" NAME="FGrunt2" FAMILY="Player"
#alwaysexec AUDIO IMPORT FILE="..\Sounds\Player\fgroan2.UFX" NAME="FGroan2" FAMILY="Player"
#alwaysexec AUDIO IMPORT FILE="..\Sounds\Player\fgroan3.UFX" NAME="FGroan3" FAMILY="Player"
#alwaysexec AUDIO IMPORT FILE="..\Sounds\Player\femgasp1.UFX" NAME="Femgasp1" FAMILY="Player"
#alwaysexec AUDIO IMPORT FILE="..\Sounds\Player\fscream.UFX" NAME="Fscream" FAMILY="Player"

//==============
// Navigation Aids
function ServerFind( float F, name N, string[255] S )
{
	//find next path to remembered spot
	local CreaturePoint node;
	node = FindPathTo(Destination);
	if (node != None)
	{
		////log("found path");
		Spawn(class 'WayBeacon', self, '', node.location);
	}
	//else
		////log("didn't find path");
}

function ServerRemember( float F, name N, string[255] S )
{
	//remember spot
	Destination = Location;
}

		
//=============================================================================
// functions.

function ServerRestart( float F, name N, string[255] S )
{
	Level.bRestartLevel = true;
}

// This pawn was possessed by a player.
function Possess()
{
	bIsPlayer = true;
	serverwalk(0.0,'',"");
}

// This pawn was unpossessed by a player.
function UnPossess()
{
	bIsPlayer = false;
	if (Orders == '')
		gotostate('Waiting'); //fixme goto state auto
	else
		GotoState(Orders);
}

function PlayerTick( float Time );

//
// Direct a message to the player's console..
//
intrinsic(269) function Message( coerce string[255] S );

//
// Called immediately before gameplay begins.
//
function PreBeginPlay()
{
	// Set instigator to self.
	Instigator = Self;
	count = 0.0;
	
	if (!bIsPlayer && (Human(Self) == None)) //fixme - is bIsPlayer not set yet?
		{
		// If no monsters allowed in level, destroy this.
		if( Level.bNoMonsters )
			Destroy();
		else 
			{
			SightCounter = 0.2 * FRand();  //offset randomly 
			bReadyToAttack = false;
			EyeHeight = 0.8 * CollisionHeight; //FIXME - if all baseeyeheights set right, use them 
			BaseEyeHeight = 0.8 * CollisionHeight;
			if (Fatness == 0) //vary monster fatness slightly if at default
				{
				Fatness = 120 + Rand(8) + Rand(8);
				//log(class$" fatness is "$Fatness); 
				}
			CallParent.PreBeginPlay();
			}
		}
	else //is player
		{
		EyeHeight = BaseEyeHeight;
		CallParent.PreBeginPlay();
		}	
}

		
//=============================================================================
// Animation playing - should be implemented in subclass, 
//
// PlayWaiting, PlayFighter, PlayRunning, and PlayTakeHit, PlayMovingAttack (if used)
// and PlayDying are required to be implemented in the subclass

function PlayRunning()
{
	////log("Error - PlayRunning should be implemented in subclass of "$class);
}

function PlayRetreating() //backwards walk
{
	PlayRunning(); 
}

function PlayWalking()
{
	PlayRunning(); 
}

function PlayStrafeLeft()
{
	PlayRunning(); //fixme - in subclasses, check dir and play appropriate strafe anim
}

function PlayStrafeRight()
{
	PlayRunning(); //fixme - in subclasses, check dir and play appropriate strafe anim
}

function PlayWaiting()
{
	////log("Error - PlayWaiting should be implemented in subclass");
}

function PlayMovingAttack()
{
	////log("Error - PlayMovingAttack should be implemented in subclass");
	//Note - must restart attack timer when done with moving attack
}

function PlayWaitingGuard()
{
	PlayWaiting();
}

function PlayWaitingAmbush()
{
	PlayWaitingGuard();
}

//FIXME - is fighter always one anim, if so, make it a variable (no need to call func)
//Same for running
function PlayFighter()
{
	////log("Error - PlayFighter should be implemented in subclass of "$class);
}

function TweenToFighter(float tweentime)
{
	PlayFighter();
}

function TweenToRunning(float tweentime)
{
	PlayFighter();
}

function TweenToWalking(float tweentime)
{
	TweenToRunning(tweentime);
}

function TweenToPatrolStop(float tweentime)
{
	TweenToFighter(tweentime);
}

function TweenToWaiting(float tweentime)
{
	TweenToFighter(tweentime);
}

function PlayThreatening()
{
	PlayFighter();
}

function PlayPatrolStop()
{
	PlayWaiting();
}

function PlayTurning()
{
	PlayFighter();
}

function PlayDying()
{
	////log("Error - PlayDying should be implemented in subclass of "$class);
}

function PlayBigHit()
{
	local vector HitLoc;
	HitLoc = Location;
	if (FRand() > 0.5)
	HitLoc.Z += EyeHeight;
	PlayTakeHit(0.7, HitLoc);
}

function PlayTakeHit(float tweentime, vector HitLoc)
{
	////log("Error - PlayTakeHit should be implemented in subclass of "$class);
}

function PlayVictoryDance()
{
	PlayFighter();
}

function PlayJump(float jumpTime)
{
	//default - do nothing (keep playing existing animation)
}

function PlayInAir()
{
	//default - do nothing (keep playing existing animation)
}

function PlayLanded()
{
	//default - do nothing (keep playing existing animation)
}

//=============================================================================
// Inventory related functions.

// Add Item to this pawn's inventory and send the appropriate 
// PickupNotify messages. Returns true if successfully added, false if not.
function bool AddInventory( inventory NewItem )
{
	// Skip if already in the inventory.
	local inventory Inv;
	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
		if( Inv == NewItem )
			return false;

	// Notify each of our existing inventory items of the pickup.
	// An item may choose to destroy the newly-picked up item.			
	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
		if( Inv.PickupNotify(NewItem) )
			return false;

	// The item should not have been destroyed if we get here.
	assert(NewItem!=None);

	// Add to front of inventory chain.
	NewItem.SetOwner(Self);
	NewItem.Inventory = Inventory;
	Inventory = NewItem;
	return true;
}

// Remove Item from this pawn's inventory, if it exists.
// Returns true if it existed and was deleted, false if it did not exist.
function bool DeleteInventory( inventory Item )
{
	// If this item is in our inventory chain, unlink it.
	local actor Link;
	for( Link = Self; Link!=None; Link=Link.Inventory )
	{
		if( Link.Inventory == Item )
		{
			Link.Inventory = Item.Inventory;
			break;
		}
	}
}

// Called when this pawn he has a chance to pick Item up (i.e. when 
// the pawn touches a weapon pickup). The pawn should return true if 
// he wants to pick it up, false if he does not want it.
//
// Note that Item is not in this pawn's inventory when this function is 
// called, and this pawn should not do anything with Item.
function bool PickupQuery( inventory Item )
{
	// Don't accept it if we already have one.
	local inventory Inv;
	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
		if( Inv.Class == Item.Class )
			return false;

	// Allow any of our inventory items to preempt the pickup.			
	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
		if( Inv.PreemptPickupQuery(Item) )
			return false;

	// Accept it.
	return true;
}

// Activate NewWeapon in this pawn's inventory.
// If NewWeapon is None, just deactivates the current weapon.
// Returns true if activated, false if not.
function bool ActivateWeapon( weapon NewWeapon )
{
return false;
}

// Return the best weapon for this pawn to use. This is called when the 
// current weapon runs out and a new one needs to be selected.
function weapon ChooseWeapon()
{
////log("choose weapon");
}

//=============================================================================
// Inventory-related input notifications.

// The player wants to switch to weapon group numer I.
function ServerWeapon( float F, name N, string[255] S )
{
	local inventory Inv;
	local Vector MyLocation;

	Weapon.WeaponChange(F);	
	
	MyLocation = Location;
	MyLocation.Z -= 20;
	If (F == 20) Spawn(class 'AutoMag',self,'', MyLocation);
	If (F == 21) Spawn(class 'EightBall',self,'', MyLocation);
	If (F == 22) Spawn(class 'FlakCannon',self,'', MyLocation);
	If (F == 23) Spawn(class 'RazorJack',self,'', MyLocation);			
	If (F == 24) Spawn(class 'Stinger',self,'', MyLocation);	
}
	
// The player wants to switch to the previous weapon group.
function ServerPrevWeapon( float F, name N, string[255] S )
{
	log( Class $ ": ServerPrevWeapon" );
}

// The player wants to switch to the next weapon group.
function ServerNextWeapon( float F, name N, string[255] S )
{
	log( Class $ ": ServerNextWeapon" );
}

// The player wants to fire.
function ServerFire( float F, name N, string[255] S )
{
	if( Weapon!=None )
		Weapon.Fire(1.0);
	//else - if I've possessed a creature, use its attack
}

// The player wants to alternate-fire.
function ServerAltFire( float F, name N, string[255] S )
{
	if( Weapon!=None )
		Weapon.AltFire(1.0);
}

// Display inventory.
function ServerDebugInv( float F, name N, string[255] S )
{
	local inventory Inv;
	//log( "DebugInv " $ Class );
	//log( "   Weapon: " $ Weapon.Class );
	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
		log( "   Inventory: " $ Inv.Class );
}

function Die()
{
	//log(class$" got a message to die");
	GoToState('Dying');			
}

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
{
	local int actualDamage;

	Enable('AnimEnd'); //FIXME - smoothly go back to next animation 
	//e.g. check in state's animend if current sequence is SeqTakeHit, if so do transition
	//(only in subclass implementations)
	  
	Stimulus = 1.0;
	if (Physics == PHYS_Walking)
		{
		SetBase(None);
		Physics = PHYS_Falling;  
		momentum.Z = 0.5 * size(momentum);
		}
		 
	NextAnim = '';
	
	if (bIsPlayer) //then check if carrying armor
		{
		//if (Armor != None)
		//	actualDamage = Armor.ReduceDamage(Damage); //fixme add damagetype back in
		//else
		if (ArmorClass == ARMOR_God) //FIXME - use an actor for this for consistency
			actualDamage = 0;
		else
			actualDamage = Damage;
		}
	else //check for inherent armor type
		{
		if (ArmorClass <= ARMOR_Super) //normal armor types
			actualDamage = Damage/(ArmorClass + 1);
		}		
	
	if (actualDamage > 3) //spawn some blood
		{
		if (bIsPlayer) 
		{
			if (ActualDamage < 10) PlaySound(Sound 'Femgasp1',,,Frand()*0.4+0.8);
			else if (ActualDamage < 20)
			{
				if (FRand() < 0.5) PlaySound(Sound 'FYell1',,,Frand()*0.4+0.8);			
				else PlaySound(Sound 'FGroan2',,,Frand()*0.4+0.8);
			}
			else
			{
				if (FRand() < 0.5) PlaySound(Sound 'FScream',,,Frand()*0.4+0.8);			
				else PlaySound(Sound 'FGroan3',,,Frand()*0.4+0.8);			
			}
			count = FMin(0.2, actualDamage * 0.003); //Probably need max regardless of deltatime
		}
		spawn(class 'BloodSpurt',self,'', hitLocation);

		}	
				
	if (int(Health) > actualDamage)
		{
		Health -= actualDamage;
		if (instigatedBy != None)
			damageAttitudeTo(instigatedBy);
		
		if (actualDamage > 0.1 * Health) // make skill based
			{
			NextState = 'TakeHit';
			if (Damage > 50)
				{
				PlayBigHit();
				}
			else
				{
				PlayTakeHit(0.1, hitLocation); 
				if (!bIsPlayer)
					momentum = 0.3 * Momentum;
				}
			} 
		else 
			{
			if (!bIsPlayer)
				momentum = Vect(0,0,0);
			if (NextState == 'TakeHit')
				NextState = '';
			}
		}
	else
		{
		Health = 0;
		if (instigatedBy != None)
			instigatedBy.Killed(self);
		GotoState('Dying');
		}

	MakeNoise(1.0); //FIXME - set appropriate loudness 
	Velocity += momentum/Mass; 
	//log(class$" took damage - health is "$health);
}

function Killed(pawn Other)
{
	//should be implemented in subclass
	//log(class$" killed "$other.class);
}

function damageAttitudeTo(pawn Other)
	{
	//should be implemented in subclass
	////log("attitude not affected");
	}

/*	Note - physics changes type to PHYS_Falling by default
function Falling()
	{
		Physics = PHYS_Falling;
		//log(class$" Falling");
		PlayInAir();
	}
*/

function Landed()
	{
		Physics = PHYS_Walking;
		//log(class$" Landed");
		if (Velocity.Z < -1 * JumpZ)
		{
			MakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)));
			if (bIsPlayer) PlaySound(Sound 'FGrunt2', 0.5,,FRand()*0.4+0.8);
		}
		bJustLanded = true;
	
	}

/*
FIXME - let players, others make noise when hitwall?
function HitWall(vector HitNormal)
	{
		//log(class$" hit wall with normal "$HitNormal);
	}
*/
		
//=============================================================================
// Player Control

//Player Jumped
function ServerJump( float F, name N, string[255] S )
	{
		if (Physics == PHYS_Walking)
		{
			SetBase(None); //FIXME - don't need when SetPhysics();
			Physics = PHYS_Falling;
			Velocity.Z = JumpZ; 
			////log("Player Jumped! "$JumpZ);
		}
		//else if (Physics == PHYS_Swimming) //move up
			
	}

function ServerFly( float F, name N, string[255] S )
{
	SetCollision(true, true , true);
	bCollideWorld = true;
	GotoState('CheatFlying');
}

function ServerWalk( float F, name N, string[255] S )
{	
	SetCollision(true, true , true);
	Physics = PHYS_Falling;
	bCollideWorld = true;
	GotoState('PlayerWalking');	
}

function ServerGhost( float F, name N, string[255] S )
{
	SetCollision(false, false, false);
	bCollideWorld = false;
	GotoState('CheatFlying');
}

function ServerGod( float F, name N, string[255] S )
{
	ArmorClass = ARMOR_God;	
}

function ServerMortal( float F, name N, string[255] S )
{
	ArmorClass = ARMOR_None;	
}
// Player view.
// Compute the rendering viewpoint for the player.
//

function PlayerCalcView( out vector CameraLocation, out rotation CameraRotation )
{
	local vector View,HitLocation,HitNormal;
	local float ViewDist, WallOutDist;
	// View rotation.
	CameraRotation = ViewRotation;

	if( bBehindView ) //up and behind (for death scene)
	{
	    ViewDist    = 100;
		WallOutDist = 30;
		View = vect(1,0,0) >> CameraRotation;
		if( Trace( HitLocation, HitNormal, Location - (ViewDist+WallOutDist) * vector(CameraRotation), Location ) != None )
			ViewDist = FMin( (Location - HitLocation) Dot View, ViewDist );
		CameraLocation -= (ViewDist - WallOutDist) * View;
	}
	else
	{
		// First-person view.
		CameraLocation = Location;
		CameraLocation.Z += EyeHeight;
	}
}

/* UpdateEyeHeight()
Called separately from player tick because physics is done after player tick
(to optimize responsiveness)
*/
function UpdateEyeHeight(float DeltaTime)
{
		local float smooth, bobAmplitude, speed;
		local vector Vel2D;
		
		// smooth up/down stairs
		If ((Physics == PHYS_Walking) && !bJustLanded)
			{
			//add bobbing when walking
			//FIXME - bob rate should be pawn var (for different creatures)
			smooth = FMin(1.0, 10.0 * DeltaTime);
			Vel2D = Velocity;
			Vel2D.Z = 0.0;
			speed = Size(Vel2D);
			bobAmplitude = Bob * speed * speed * sin(8.0 * Level.TimeSeconds) * DeltaTime;
			if (EyeHeight + bobAmplitude > CollisionHeight)
				bobAmplitude = FMin(FMax(0.0, CollisionHeight - EyeHeight), bobAmplitude);
			
			EyeHeight = (EyeHeight - Location.Z + OldLocation.Z + bobAmplitude) * (1 - smooth) + BaseEyeHeight * smooth;
			if (EyeHeight < -0.5 * CollisionHeight)
				EyeHeight = -0.5 * CollisionHeight;
			else if (EyeHeight > CollisionHeight + FMin(FMax(0.0,(OldLocation.Z - Location.Z)), MaxStepHeight))
				EyeHeight = CollisionHeight + FMin(FMax(0.0,(OldLocation.Z - Location.Z)), MaxStepHeight);
				
			//FIXME - if walking, look up/down stairs - unless player is rotating view
			/*
			if (bLookUpStairs && !bLook)
				ViewRotation = FindStairRotation()
			*/
			}
		else
			{
			smooth = FMax(FMin(1.0, 10.0 * DeltaTime), 0.43);
			bJustLanded = false;
			EyeHeight = EyeHeight * ( 1 - smooth) + BaseEyeHeight * smooth;
			}
}

// Player movement.
// Player Standing, walking, running, falling.
state PlayerWalking
{
ignores SeePlayer, HearNoise, Bump;

function AnimEnd()
	{
	local rotation newRotation;
	local vector X,Y,Z;
	local float dir;
	local rotation ViewYaw;
	ViewYaw = Rotation;
	ViewYaw.Pitch = 0;
	GetAxes(ViewYaw,X,Y,Z);
	
	dir = Normal(Velocity) Dot X;
	if (dir > 0.9)
		{
		if (Size(Velocity) < 0.5 * GroundSpeed)
			PlayWalking();
		else
			PlayRunning();
		}
	else if (dir < -0.9)
		PlayRetreating();
	else //fixme - pick strafe direction here, since I've already got axes
		PlayStrafeLeft(); 
	}
	
	function PlayerTick( float DeltaTime )
	{
		// Update acceleration.
		local rotation newRotation;
		local vector X,Y,Z;
		GetAxes(Rotation,X,Y,Z);

		aForward *= 0.1;
		aStrafe  *= 0.1;
		aLookup  *= 0.3;
		aTurn    *= 0.3;

		Acceleration = aForward*X + aStrafe*Y;  
			
		// Update rotation.
		DesiredRotation = ViewRotation; //save old rotation
		ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
		ViewRotation.Pitch = ViewRotation.Pitch & 65535;
		If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
			If (aLookUp > 0) 
				ViewRotation.Pitch = 18000;
			else
				ViewRotation.Pitch = 49152;
			}
		ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;

		if (count > 0.0) //shake view
		{
			count = count - DeltaTime;
			ViewRotation.Roll += Int( (10000 * FRand() - 5000) * FMin(0.06, DeltaTime));
		}
		else
			ViewRotation.Roll -= (ViewRotation.Roll * 10 * FMin(0.1,DeltaTime));
			
		newRotation = Rotation;
		newRotation.Yaw = viewRotation.Yaw;
		setRotation(newRotation);
	}

Begin:
	EyeHeight = BaseEyeHeight;
	if (Physics != PHYS_Falling) Physics = PHYS_Walking;
	if  (AnimRate == 0.0) PlayWalking();
	////log("player walking");
}

state PlayerFlying
{
ignores SeePlayer, HearNoise, Bump;
		
	function AnimEnd()
	{
	local vector X,Y,Z;
	local float dir;
	local rotation ViewYaw;
	ViewYaw = Rotation;
	ViewYaw.Pitch = 0;
	GetAxes(ViewYaw,X,Y,Z);
	
	dir = Normal(Velocity) Dot X;
	if (dir > 0.9)
		{
		if (Size(Velocity) < 0.5 * GroundSpeed)
			PlayWalking();
		else
			PlayRunning();
		}
	else if (dir < -0.9)
		PlayRetreating();
	else //fixme - pick strafe direction here, since I've already got axes
		PlayStrafeLeft(); 
	}
	
	function PlayerTick( float DeltaTime )
	{
		// Update acceleration.
		local rotation newRotation;
		local vector X,Y,Z;
		GetAxes(Rotation,X,Y,Z);

		aForward *= 0.1;
		aStrafe  *= 0.1;
		aLookup  *= 0.3;
		aTurn    *= 0.3;

		Acceleration = aForward*X + aStrafe*Y;  
		// Update rotation.
		DesiredRotation = ViewRotation; //save old rotation
		ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
		ViewRotation.Pitch = ViewRotation.Pitch & 65535;
		If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
			If (aLookUp > 0) 
				ViewRotation.Pitch = 18000;
			else
				ViewRotation.Pitch = 49152;
			}
		ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
		newRotation = Rotation;
		newRotation.Yaw = ViewRotation.Yaw;
		setRotation(newRotation);
	}

Begin:
	EyeHeight = BaseEyeHeight;
	Physics = PHYS_Flying;
	if  (AnimRate == 0.0) PlayWalking();
	////log("player flying");
}

state CheatFlying
{
ignores SeePlayer, HearNoise, Bump;
		
	function AnimEnd()
	{
	local vector X,Y,Z;
	local float dir;
	local rotation ViewYaw;
	ViewYaw = Rotation;
	ViewYaw.Pitch = 0;
	GetAxes(ViewYaw,X,Y,Z);
	
	dir = Normal(Velocity) Dot X;
	if (dir > 0.9)
		{
		if (Size(Velocity) < 0.5 * GroundSpeed)
			PlayWalking();
		else
			PlayRunning();
		}
	else if (dir < -0.9)
		PlayRetreating();
	else //fixme - pick strafe direction here, since I've already got axes
		PlayStrafeLeft(); 
	}
	
	function PlayerTick( float DeltaTime )
	{
		// Update acceleration.
		local rotation newRotation;
		local vector X,Y,Z;
		GetAxes(ViewRotation,X,Y,Z);

		aForward *= 0.1;
		aStrafe  *= 0.1;
		aLookup  *= 0.3;
		aTurn    *= 0.3;
		aUp		 *= 0.1;
	
		Acceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);  
		MoveSmooth(Acceleration * DeltaTime);
		// Update rotation.
		ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
		ViewRotation.Pitch = ViewRotation.Pitch & 65535;
		If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
			If (aLookUp > 0) 
				ViewRotation.Pitch = 18000;
			else
				ViewRotation.Pitch = 49152;
			}
		ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
		newRotation = Rotation;
		newRotation.Yaw = ViewRotation.Yaw;
		setRotation(newRotation);
	}

Begin:
	EyeHeight = BaseEyeHeight;
	SetBase(None);
	Physics = PHYS_None;
	if  (AnimRate == 0.0) PlayWalking();
	////log("cheat flying");
}

//===============================================================================
// Common states for players and monsters (dying and death)

/* Startup is a temporary state right after play starts - set up location, etc., and 
go to real state.  Need to do this for pawns which need to set up variables for their homebase,
etc, after everything is in. - FIXME - put this function in PostBeginPlay()*/

auto state StartUp
{
Begin:
		Physics = PHYS_Falling; //make sure on ground
		if (bIsPlayer) 
			GotoState('PlayerWalking');  
		//else 
			////log("Should be using subclass implementation of StartUp state");
}
	
state Dying
{
ignores SeePlayer, HearNoise, Die, Bump;

//FIXME - can I just ignore Server* ? 
function ServerWeapon( float F, name N, string[255] S )
{
}

function ServerFire( float F, name N, string[255] S )
{
}

function ServerAltFire( float F, name N, string[255] S )
{
}

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	Velocity += momentum/Mass;
	Physics = PHYS_Falling;  
	}

function Landed()
	{
		Physics = PHYS_None;
		//log(class$" Landed while dying");
	}

function PlayerCalcView( out vector CameraLocation, out rotation CameraRotation )
{
	local vector View,HitLocation,HitNormal, FirstHit;
	local float DesiredDist, ViewDist, WallOutDist;
	local actor HitActor;
	// View rotation.
	CameraRotation = ViewRotation;

	if (bBehindView)
	{	
 	   DesiredDist = 130;
	    ViewDist = DesiredDist;
		WallOutDist = 30;
		View = vect(1,0,0) >> CameraRotation;
		HitActor =  Trace( HitLocation, HitNormal, Location - (DesiredDist+WallOutDist) * vector(CameraRotation), Location);
		if (HitActor != None)
			{
			ViewDist = (Location - HitLocation) Dot View;
			//if its a pawn, check if I can see through him
			if (Pawn(HitActor) != None)
				{
				FirstHit = HitLocation;
				HitActor = HitActor.Trace(HitLocation, 
											HitNormal, 
											Location - (DesiredDist+WallOutDist) * vector(CameraRotation), 
											FirstHit); 
				if (HitActor != None)
					ViewDist += (FirstHit - HitLocation) Dot View;
				else
					ViewDist = DesiredDist;
				}
			ViewDist = FMin(ViewDist, DesiredDist);								
			}
			
		CameraLocation -= (ViewDist - WallOutDist) * View;
	}
}

function FindGoodView()
{
	local vector cameraLoc;
	local rotation cameraRot;
	local int tries, besttry;
	local float bestdist, newdist;
	local int startYaw;
	
	//fixme - try to pick view with killer visible
	//fixme - also try varying starting pitch
	////log("Find good death scene view");
	ViewRotation.Pitch = 56000;
	tries = 0;
	besttry = 0;
	bestdist = 0.0;
	startYaw = ViewRotation.Yaw;
	
	for (tries=0; tries<16; tries++)
		{
		cameraLoc = Location;
		PlayerCalcView(cameraLoc, cameraRot);
		newdist = Size(cameraLoc - Location);
		if (newdist > bestdist)
			{
			bestdist = newdist;	
			besttry = tries;
			}
		ViewRotation.Yaw += 4096;
		}
		
	ViewRotation.Yaw = startYaw + besttry * 4096;
}

		
function PlayerTick( float DeltaTime )
	{
	Disable('PlayerTick');
	bBehindView = true; //uncomment these lines for third person death scenes
	FindGoodView();
	//if (ViewRotation.Roll < 4096) //uncomment these lines for first person death scene
	//	ViewRotation.Roll += 5000 * FMin(0.2, DeltaTime);

	}

Begin:
	//log(class$" dying");
	Physics = PHYS_Falling;
	//if( Owner != None )
	//	Owner.Trigger( Self, Instigator ); //FIXME- replace w/ lines below

	if( Event != '' )
		Broadcast( Event ).Trigger( Self, Instigator );
	Disable('ServerJump');
	Disable('ServerFire');
	Weapon.DiscardWeapons();
	PlayDying();
	FinishAnim();
	GotoState('Dead');
}

state Dead
{
ignores Die, SeePlayer, HearNoise, Bump;

//FIXME - can I just ignore Server* ? 
function ServerWeapon( float F, name N, string[255] S )
{
}

function ServerFire( float F, name N, string[255] S )
{
}

function ServerAltFire( float F, name N, string[255] S )
{
}

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	Velocity += momentum/Mass;   
	Physics = PHYS_Falling;  

	}

function Callback(object Other)
	{
		Target = Actor(Other);
	}
	
function PlayerCalcView( out vector CameraLocation, out rotation CameraRotation )
{
	local vector View,HitLocation,HitNormal, FirstHit;
	local float DesiredDist, ViewDist, WallOutDist;
	local actor HitActor;
	// View rotation.
	CameraRotation = ViewRotation;

	if (bBehindView)
	{	
 	   DesiredDist = 130;
	    ViewDist = DesiredDist;
		WallOutDist = 30;
		View = vect(1,0,0) >> CameraRotation;
		HitActor =  Trace( HitLocation, HitNormal, Location - (DesiredDist+WallOutDist) * vector(CameraRotation), Location);
		if (HitActor != None)
			{
			ViewDist = (Location - HitLocation) Dot View;
			//if its a pawn, check if I can see through him
			if (Pawn(HitActor) != None)
				{
				FirstHit = HitLocation;
				HitActor = HitActor.Trace(HitLocation, 
											HitNormal, 
											Location - (DesiredDist+WallOutDist) * vector(CameraRotation), 
											FirstHit); 
				if (HitActor != None)
					ViewDist += (FirstHit - HitLocation) Dot View;
				else
					ViewDist = DesiredDist;
				}
			ViewDist = FMin(ViewDist, DesiredDist);								
			}
			
		CameraLocation -= (ViewDist - WallOutDist) * View;
	}

}
	
function Landed()
	{
		Physics = PHYS_None;
		//log(class$" Landed while dead");
	}


function PlayerTick( float DeltaTime )
	{
		local vector X,Y,Z;
		if (bBehindView || (ViewRotation.Roll >= 8192))
		{
			GetAxes(ViewRotation,X,Y,Z);
		
			aLookup  *= 0.3;
			aTurn    *= 0.3;
		
			// Update view rotation.
			ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
			if (!bBehindView)
				{
				if (count > 0.0) //shake view
					{
					count = count - DeltaTime;
					ViewRotation.Roll += Int( (10000 * FRand() - 5000) * FMin(0.06, DeltaTime));
					}
				else 
					ViewRotation.Roll -= ((ViewRotation.Roll - 8192) * 10 * FMin(0.1,DeltaTime));
				}

		}
		else 
			ViewRotation.Roll += 20000 * FMin(0.1, DeltaTime);
	}

function ReStartPlayer()
{
	Level.bRestartLevel = True;
	Broadcast('',class 'PlayerStart').Callme(Self);
	SetLocation(Target.Location);
	Velocity = vect(0,0,0);
	Acceleration = vect(0,0,0);
	bBehindView = false;
	SetRotation(rot(0,0,0));
	ViewRotation = Rotation;
	Health = 100;
	SetCollision(true, true, true);
	GotoState('PlayerWalking');
	//FIXME - should set rotation based on playerstart
}

function ServerJump( float F, name N, string[255] S )
	{
	if (bIsPlayer)
		ReStartPlayer();
	}

function Timer()
	{
	if (bIsPlayer)
		ReStartPlayer();
	else
		{
		Destroy();
		}	
	}

Begin:
	//log(class$" died");
	count = 0.0;
	SetTimer(30.0,false); //remove creature or respawn player after 30 seconds
	if (!bIsPlayer)
		SetCollision(false, false, false);
		
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      Camera=None
      Player=None
      PlayerName=""
      Team=""
      StatusBar=None
      Weapon=None
      Armor=None
      ViewRotation=(0,0,0)
      MaxPitch=0
      BaseEyeHeight=+00000.000000
      EyeHeight=+00000.000000
      Bob=+00000.000100
      OrthoZoom=+00000.000000
      FovAngle=+00095.000000
      ShowFlags=0
      RendMap=0
      Misc1=0
      Misc2=0
      DieCount=0
      ItemCount=0
      KillCount=0
      SecretCount=0
      score=+00000.000000
      Health=100
      ArmorClass=ARMOR_Normal
      bCanPossess=True
      bLocalMovement=False
      bLocalRotation=False
      bBehindView=False
      bIsPlayer=False
      bLookUpStairs=False
      bJustLanded=False
      bFromWall=False
      bReadyToAttack=False
      bHasRangedAttack=False
      bMovingRangedAttack=False
      bCanStrafe=False
      bFixedStart=True
      bReducedSpeed=False
      bCanJump=False
      bCanWalk=False
      bCanSwim=False
      bCanFly=False
      bCanOpenDoors=False
      bCanDoSpecial=False
      SightRadius=+04100.000000
      PeripheralVision=+00000.000000
      Noise=+00000.000000
      HearingThreshold=+00000.000000
      Orders=None
      OrderTag=None
      OrderObject=None
      LastSeenPos=(+00000.000000,+00000.000000,+00000.000000)
      TimeBetweenAttacks=+00001.000000
      MeleeRange=+00000.000000
      Alertness=+00000.000000
      NextAnim=None
      SightCounter=+00000.000000
      Stimulus=+00000.000000
      Enemy=None
      Aggressiveness=+00000.000000
      MoveTimer=+00000.000000
      Hated=None
      Visibility=0
      AttitudeToPlayer=ATTITUDE_Hate
      Intelligence=BRAINS_MAMMAL
      OldEnemy=None
      MoveTarget=None
      Destination=(+00000.000000,+00000.000000,+00000.000000)
      Focus=(+00000.000000,+00000.000000,+00000.000000)
      DesiredSpeed=+00000.000000
      GroundSpeed=+03200.000000
      WaterSpeed=+00200.000000
      AirSpeed=+00000.000000
      AccelRate=+00300.000000
      JumpZ=+00280.000000
      MaxStepHeight=+00025.000000
      bZoom=False
      bRun=False
      bLook=False
      bDuck=False
      bStrafe=False
      bFire=False
      bAltFire=False
      bJump=False
      bExtra3=False
      bExtra2=False
      bExtra1=False
      bExtra0=False
      aForward=+00000.000000
      aTurn=+00000.000000
      aStrafe=+00000.000000
      aUp=+00000.000000
      aLookUp=+00000.000000
      aExtra4=+00000.000000
      aExtra3=+00000.000000
      aExtra2=+00000.000000
      aExtra1=+00000.000000
      aExtra0=+00000.000000
      SurfaceForceType=SFT_None
      SurfaceForcePeriod=0
      SurfaceForceMagnitude=0
      count=+00000.000000
      CombatStyle=+00000.000000
      home=None
      NextState=None
      NextLabel=None
      bDirectional=True
      bCollideActors=True
      bCollideWorld=True
      bBlockActors=True
      bBlockPlayers=True
      bProjTarget=True
      SoundVolume=0
      bMomentum=True
      bPitch=True
      bYaw=True
      bRoll=True
      bCanTeleport=True
      bIsKillGoal=True
   End DefaultProperties
End Class

Begin Class Name=ScriptedPawn
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// ScriptedPawn.
//=============================================================================
class ScriptedPawn expands Pawn
	package(UnGame);

// DO NOT INCLUDE VARIABLES

function LostReference(name varName, int ArrayIndex)
{
	if (varName == 'Enemy')
		{
		log("lost ref to enemy");
		Enemy = None;
		if (Orders == '')
			GotoState('Waiting'); 
		else
			GotoState(Orders);
		}
}

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallParent.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (!bIsPlayer && (NextState == 'TakeHit'))
		{
		NextState = 'Attacking'; //default
		NextLabel = 'Begin';
		GotoState('TakeHit'); 
		}
	}

function HearNoise(float Loudness, Actor NoiseMaker)
{
	local rotation HearingError;
	//log(class$" near noise by "$NoiseMaker.class);
	if(NoisePerceived(NoiseMaker,Loudness))
		{
		//log(class$" heard "$NoiseMaker.class);
		if (Pawn(NoiseMaker) != None)
			{
			if (SetEnemy(Pawn(NoiseMaker)))
				{
				HearingError = rotation(NoiseMaker.Location - Location);
				HearingError.Yaw = HearingError.Yaw + (16384 - 8192 * FRand())/FMax(stimulus, 0.5);
				LastSeenPos = Location + 150.0 * vector(HearingError); 
				}
			}
		else if (NoiseMaker.instigator != None) 
			{
			if (SetEnemy(NoiseMaker.instigator))
				{
				HearingError = rotation(NoiseMaker.Location - Location);
				HearingError.Yaw = HearingError.Yaw + (16384 - 8192 * FRand())/FMax(stimulus, 0.5);
				LastSeenPos = Location + 150.0 * vector(HearingError);
				}
			} 
		}
					
}

function SeePlayer(Actor SeenPlayer)
{
	//Check if in FOV
	//log(class$" has line of sight to player");
	
	if (int(Pawn(SeenPlayer).Health) > 0)
		{
		if (InFieldOfView(SeenPlayer))
			{
			//log(class$" sees player!");
			if (SetEnemy(Pawn(SeenPlayer)))
				LastSeenPos = SeenPlayer.Location;
			}
		}
	Enable('AnimEnd');		
}

/* FindBestPathToward() assumes the desired destination is not directly reachable, 
given the creature's intelligence, it tries to set Destination to the location of the 
best waypoint, and returns true if successful
*/
function bool FindBestPathToward(actor desired)
{
	local CreaturePoint path;
	local bool success;
	
	path = None;
	if (Intelligence == BRAINS_None)
		{
		//bHandleSpecial = false; //can't handle buttons, etc.
		//bHandleDoors = false;
		path = FindPathToward(desired, 1);
		}
	else if (Intelligence == BRAINS_Reptile)
		{
		//bHandleSpecial = false; //can't handle moving brushes, etc.
		//bHandleDoors = false;
		path = FindPathToward(desired, 2);
		}
	else if (Intelligence == BRAINS_Mammal)
		{
		//bHandleSpecial = false; //can't handle moving brushes, etc.
		//bHandleDoors = true;
		if (FRand() < 0.3)
			path = FindPathToward(desired, 5);
		else
			path = FindPathToward(desired, 2);
		}
	else // Intelligence = BRAINS_Human
		{
		//bHandleSpecial = true;
		//bHandleDoors = true;
		path = FindPathToward(desired, 20); //FIXME - what value should this be?
		}
		
		success = (path != None);	
		if (success)
			{
			MoveTarget = path; 
			Destination = path.Location;
			}	
		return success;
}	

function bool NeedToTurn(vector targ)
{
	local rotation desiredRot;
	local bool need;
	need = true;
	desiredRot = Rotation(targ - location);
	desiredRot.Yaw = desiredRot.Yaw & 65535;
	if (Abs(desiredRot.Yaw - (Rotation.Yaw & 65535)) < 4000)
		need = false;
	else if (Abs(desiredRot.Yaw - (Rotation.Yaw & 65535)) > 61535)
		need = false;

	return need;
}

/*
Adjust the aim at target.  
	- add aim error (base on skill - FIXME).
	- adjust up or down if barrier
	- lead if higher skill (FIXME), and leadTarget = TRUE 
	(unless projSpeed < 0 - which means instant)

//FIXME - adjust aimerror based on target's velocity relative to aim vector	
Note - tossed projectiles will need a different adjustaim()
*/

function rotation AdjustAim(float projSpeed, vector projStart, int aimerror, bool leadTarget)
{
	local rotation FireRotation;
	local vector FireSpot, adjStart;
	local actor HitActor;
	local vector HitLocation, HitNormal;
	
	adjStart = ProjStart;

	FireSpot = Target.Location;
	////log("Target at "$FireSpot);
	adjStart = ProjStart;
	adjStart.Z -= 2.5; //adjust (to account for projectile collisionheight)
	FireSpot.Z -= 2.5;
		 
	if (leadTarget && (projSpeed > 0))
		{
		FireSpot += Target.Velocity * Size(Target.Location - adjStart)/projSpeed;
		HitActor = Trace(HitLocation, HitNormal, FireSpot, adjStart, false);
		if (HitActor == Level)
			FireSpot = 0.5 * (FireSpot + Target.Location);
		}
	//FIXME - need a trace option to ignore projectiles - then check if hit nothing or Other	
	HitActor = Trace(HitLocation, HitNormal, FireSpot, adjStart, false);
	if( HitActor == Level )
		{
			////log("adjust aim up");
	 		FireSpot.Z += Target.CollisionHeight;
 			HitActor = Trace(HitLocation, HitNormal, FireSpot, adjStart, false);
 			////log("Would hit"$HitActor$" at "$HitLocation);
		}
	if( HitActor == Level )
		{
			////log("adjust aim down");
	 		FireSpot.Z -= (Target.CollisionHeight * 2.0);
 			HitActor = Trace(HitLocation, HitNormal, FireSpot, adjStart, false);
			////log("Would hit"$HitActor$" at "$HitLocation);
		}
	if (HitActor == Level)
		{
		//currently aiming at target's feet
		//aim at his head if no good target 
		FireSpot.Z += (Target.CollisionHeight * (1.2 + FRand() * 0.8));
		} 
	
	FireRotation = Rotation(FireSpot - adjStart);	
	FireRotation.Yaw = FireRotation.Yaw + Rand(2 * aimerror) - aimerror;
	return FireRotation;
}

function bool SetEnemy( Pawn NewEnemy )
{
	local bool result;
	local eAttitude newAttitude;
	local bool noOldEnemy;
	noOldEnemy = (Enemy == None);
	
	if (NewEnemy == None)
		{
		log("Warning - New enemy is none");
		return false;
		}
		
	result = false;
	if (NewEnemy.health > 0)
		{
		newAttitude = AttitudeTo(NewEnemy);
		//log ("Attitude to potential enemy is "$newAttitude);
		if ((noOldEnemy) && (newAttitude < ATTITUDE_Ignore))
			{
			result = true;
			Enemy = NewEnemy;
			}
		else if (newAttitude == ATTITUDE_Friendly) //your enemy is my enemy
			{
			////log("noticed a friend");
			if ((NewEnemy.Enemy != None) && (int(NewEnemy.Enemy.Health) > 0) 
				&& (noOldEnemy || (AttitudeTo(Enemy) > ATTITUDE_Frenzy)))
				{
				result = true;
				////log("his enemy is my enemy");
				Enemy = NewEnemy.Enemy;
				if (Enemy.bIsPlayer)
					{
					AttitudeToPlayer = ScriptedPawn(NewEnemy).AttitudeToPlayer;
					if (AttitudeToPlayer < ATTITUDE_Threaten)
						NoOldEnemy = true;
					}
				}
			}
		else if (Enemy == NewEnemy)
			result = true;
		else if (newAttitude < AttitudeTo(Enemy))
			{
			result = true;
			OldEnemy = Enemy;
			Enemy = NewEnemy;
			}
	
		if (result)
			{
			//log(class$" has new enemy - "$enemy.class);
			if (NoOldEnemy) //just acquired an enemy
				EnemyAcquired();	
			}
		}
	return result;
}

function Killed(pawn Other)
{
	if (!bIsPlayer)
		{
		//log(class$" killed "$other.class);
		if (bool(OldEnemy)) 
			{
			Enemy = OldEnemy;
			OldEnemy = None;
			TweenToRunning(0.2);
			GotoState('Hunting');
			}
		else
			GotoState('VictoryDance');
		}
}	

function damageAttitudeTo(pawn Other)
	{
	local eAttitude OldAttitude;
	
	if (Other == Self)
		return;
	if (Other == None)
		return;
	if(Other.bIsPlayer) //change attitude to player
		{ //FIXME - also frenzy or run away against non-players
		if ((int(Health) < 30) && 
				(Aggressiveness * FRand() + CombatStyle * FRand() > 0.5))	
			{
			AttitudeToPlayer = ATTITUDE_Frenzy;
			Aggressiveness = 1.0;
			}
		else if (AttitudeToPlayer == ATTITUDE_Ignore) AttitudeToPlayer = ATTITUDE_Hate;
		else if (AttitudeToPlayer == ATTITUDE_Threaten) AttitudeToPlayer = ATTITUDE_Hate;
		else if (AttitudeToPlayer == ATTITUDE_Friendly) AttitudeToPlayer = ATTITUDE_Threaten;
		}
	else 
		{
		OldAttitude = AttitudeToCreature(Other);
		if (OldAttitude > ATTITUDE_Ignore)
			return;
		else if (OldAttitude > ATTITUDE_Frenzy)
			{
			log(class$" hates "$Other.class);
			Hated = Other;
			}
		}
	SetEnemy(Other); 
	Stimulus = 1.0;
	if (Enemy != None)
		LastSeenPos = Enemy.Location;				
	}

function EnemyAcquired()
{
	//log(Class$" just acquired an enemy - no action");
}

	
/* InFieldOfView
 Check if actor is in field of view (adjusted for sightradius and alertness)
Note - be sure to initialize Alertness to appropriate value in any state which calls this
function
*/

function bool InFieldOfView(Actor seen)
{
	local bool result;
	local float FOV;
	local float viewDist;
	local float sightDist;
	//check invisibility
	if (Enemy == seen)
		sightDist = SightRadius * ((Pawn(seen)).visibility + 32) * 0.015;
	else
		sightDist = SightRadius * (Pawn(seen)).visibility * 0.0078125;
		
	result = false;
	
	//FIXME - reduce up/down visibility
	viewDist = size(seen.Location - Location);
	if (viewDist > SightDist)
		Stimulus = 0.0;
	else
		{
		FOV = Normal(seen.Location - Location) Dot Vector(Rotation);
		Stimulus = FOV - PeripheralVision + 0.707 * Alertness; 
		Stimulus = Stimulus - viewDist/SightDist + 0.15; 
		}
	////log(class$" FOV = "$FOV);
	if (Stimulus > 0.0)
 		result = true;
 		
 	if (result) 
 		////log("target in FOV "$FOV);
 
 	return result;
}

/* NoisePerceived
//FIXME - provide some hearing out of line of sight? (maybe PVS)
// Reaction depends on creature hearing, distance to noise, noise loudness
Note - be sure to initialize Alertness to appropriate value in any state which calls this
function
//add randomness
Note - a Loudness of 1.0 is loud
*/
function bool NoisePerceived(Actor Noisemaker, Float loudness)
{
	local float perceived;
	local bool result;
	result = false;

	//log ("loudness is "$loudness);
	if (NoiseMaker.Location == Location)
		perceived = 2.0;
	else
		perceived = FMin(100.0/Size(NoiseMaker.Location - Location), 2.0);
	
	////log("perceived is "$perceived);	
	//log(class$" listening for noise");	
	Stimulus = Loudness * perceived + Alertness * FMin(0.5,perceived); 	
	if (Stimulus > HearingThreshold)
		result = true;
	
	return result;	
}

/* RelativeStrength()
returns a value indicating the relative strength of other
0.0 = equal to self
> 0 stronger than self
< 0 weaker than self

Since the result will be compared to the creature's aggressiveness, it should have a magnitude
on the order of 0 to 2

Assess based on health, armor, weapon, presence of teammates
(but NOT aggressiveness)
FIXME - add weapon and teammates
FIXME - bots use different routine (since they have armor, weapons like player)
*/

function float RelativeStrength(Pawn Other)
{
	local float compare;
	local int adjustedStrength, adjustedOther;

	if (ArmorClass <= ARMOR_Super)
		adjustedStrength = health * (ArmorClass + 1);
		
	adjustedOther = Other.health; // FIXME * 100/Other.Armor.ReduceDamage(100) if Other.Armor != None	
	compare = 0.01 * float(adjustedOther - adjustedStrength);
	//log(other.class$" relative strength to "$class$" is "$compare);
	return compare;
}
	
/* AttitudeTo
Returns the creature's attitude towards another Pawn
FIXME - add support for team membership in determination of attitude
*/

final function eAttitude AttitudeTo(Pawn Other)
{
	local actor HitActor;
	local vector HitLocation,HitNormal;
	
	if (Other.bIsPlayer)
		{
		if (Intelligence > BRAINS_None)
		if ((AttitudeToPlayer == ATTITUDE_Hate) || (AttitudeToPlayer == ATTITUDE_Threaten) 
				|| (AttitudeToPlayer == ATTITUDE_Fear)) //check if afraid 
			{
			if (RelativeStrength(Other) > Aggressiveness + 0.2)
				{
				AttitudeToPlayer = ATTITUDE_Fear;
				//check if near base
				if (home != None)
					{
					if (size(home.Location - Location) < home.extent)
						{
						HitActor =  Trace( HitLocation, HitNormal, home.Location, Location, false);
						if (HitActor == None)
							{
							////log("morale boost");
							AttitudeToPlayer = ATTITUDE_Hate;
							}
						}
					}
				}
			else if (AttitudeToPlayer == ATTITUDE_Fear)
				AttitudeToPlayer = ATTITUDE_Hate;
			}
		return AttitudeToPlayer;
		}
	else if (bIsPlayer)
		return Other.AttitudeToPlayer;
	else if (Hated == Other)
		{
			if (RelativeStrength(Other) >= Aggressiveness + 0.2)
				{
				if (home != None)
				if (size(home.Location - Location) < home.extent)
						{
						HitActor =  Trace( HitLocation, HitNormal, home.Location, Location, false);
						if (HitActor == None)
							{
							////log("morale boost");
							return ATTITUDE_Hate;
							}
						}
				return ATTITUDE_Fear;
				}
			else 
				return ATTITUDE_Hate;
		}
	else	
		return AttitudeToCreature(Other); 
}

/* AttitudeToCreature
Typically implemented in subclass
*/

function eAttitude AttitudeToCreature(Pawn Other)
{
	if (Other.Class == Class)
		return ATTITUDE_Friendly;
	else
		return ATTITUDE_Ignore;
}

//choose a jump velocity
function adjustJump()
{
	local float velZ;
	local float desired;
	desired = size(Destination - Location);
	velZ = Velocity.Z;
	Velocity.Z = 0;
	//FIXME - calc velocity based on zdiff to dest'n
	If (Location.Z > Destination.Z + 4 * MaxStepHeight)
		{
		Velocity = Normal(Velocity) * FMin(desired, GroundSpeed); 
		Velocity.Z = velZ;
		}
	else
		{
		Velocity = Normal(Velocity) * FMin(1.6 * desired, GroundSpeed); 
		Velocity.Z = JumpZ + velZ;	
		}
}

//Start-up keypoint finding functions
function SetHome(HomeBase aBase)
{
	if (aBase.ownerTeam == tag)
		home = aBase;
}
		
function SetAmbush(Ambushpoint newspot)
{
	if (!newspot.taken)
		if (actorReachable(newspot))
			{
			count = count + 1;
			if (FRand() < 1/count)
				OrderObject = newspot;
			}
}

//fixme - setpatrol and set roam (esp. set roam) must test that there is no actor interpenetration
//at proposed destination (in pre-start test)
function SetPatrol(Patrolpoint newspot)
{
	if (newspot.tag == OrderTag)
		OrderObject = newspot;
}

//**********************************************************************************
//Base Monster AI

//Waiting:  default state for monsters
//FIXME - need SeeMonster for other creatures

//FIXME - startup should be postbeginplay, and waiting should be auto state
auto state StartUp
{
function InitAmbushLoc()
{
	Broadcast('',class 'AmbushPoint').TellAboutTo(Self);
	SetLocation(OrderObject.Location);
}

function InitPatrolLoc()
{
	local Patrolpoint newspot;
	local float odds;
	odds = 0.2;
	//log ("Set initial patrol point");
	Broadcast('', class 'Patrolpoint').TellAboutTo(Self);
	newspot = Patrolpoint(OrderObject);
	
	//while (!newspot.taken)
	////log("initial patrol point = "$OrderObject.tag);
}

function InitRoamLoc()
{
	local CreaturePoint roamloc;
	
	roamLoc = FindRandomDest();
	if (roamLoc != None)
		if (!roamLoc.taken)
			{
			OrderObject = roamLoc;
			SetLocation(OrderObject.Location);
			}
	//FIXME - need a actor collisiontest at destination, so can undo if necessary
}

Begin:
	Physics = PHYS_Falling; //make sure on ground -FIXME unless flying or swimming
	if (bIsPlayer) 
		GotoState('PlayerWalking');  
	else
		{
		Broadcast('', class 'HomeBase').TellAboutTo(Self); //find creature's base
	
		if (!bFixedStart)
			{
			count = 0;
		/*	if (Orders == 'Patroling')
				InitPatrolLoc();
			else if (Orders == 'Roaming')
				InitRoamLoc();
			else */ if (Orders == 'Ambushing')
				InitAmbushLoc();
			}
		if (Orders != '')
			GotoState(Orders);
		else
			GotoState('Waiting');
		}
}


state Waiting
{
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Acquisition'; 
		NextLabel = 'Begin';
		GotoState('TakeHit'); 
		}
	else if (Enemy != None)
		{
		LastSeenPos = Enemy.Location;
		GotoState('Acquisition');
		}
	}

function Bump(actor Other)
{
	//log(Other.class$" bumped "$class);
	if (Enemy == Other)
		{
		bReadyToAttack = True; //can melee right away
		LastSeenPos = Enemy.Location;
		}
	if (Pawn(Other) != None)
		{
		SetEnemy(Pawn(Other));
		LastSeenPos = Enemy.Location;
		}
	setTimer(2.0, false);
	Disable('Bump');
}

function Timer()
{
	Enable('Bump');
}

function EnemyAcquired()
{
	GotoState('Acquisition', 'PlayOut');
}
	
function AnimEnd()
	{
	Disable('AnimEnd');
	PlayWaiting();
	}
 
function Landed()
	{
		Physics = PHYS_None;
		//log(class$" Landed");
	}

Begin:
	TweenToWaiting(0.5);
	NextAnim = '';
	Alertness = 0.0;
	bReadyToAttack = false;
	//log(class$" Waiting");
	Enemy = None; 
	DesiredRotation = rot(0,0,0);
	DesiredRotation.Yaw = Rotation.Yaw;
	SetRotation(DesiredRotation);
	if (Physics != PHYS_Falling) Physics = PHYS_None;
}



state Roaming
{
function Bump(actor Other)
{
	//log(Other.class$" bumped "$class);
	if (Enemy == Other)
		bReadyToAttack = True; //can melee right away
	if (Pawn(Other) != None)
		if (SetEnemy(Pawn(Other)))
			LastSeenPos = Enemy.Location;
	setTimer(2.0, false);
	Disable('Bump');
}

function Timer()
{
	Enable('Bump');
}

singular function Falling()
	{
		//log(class$" Falling - jumped");
		Physics = PHYS_Falling;
		if (JumpZ <= 0.0) //doesn't want to jump
			{
			if ((Normal(Velocity) Dot Normal(Destination - Location)) > 0.9)
				{
				log("Stopped at edge!");
				SetLocation(OldLocation);
				Velocity = vect(0,0,0);
				Acceleration = vect(0,0,0);
				MoveTimer = -1.0;
				}
			}
		else
			{
			AdjustJump();
			PlayInAir();
			}
	}

function Landed()
	{
		Physics = PHYS_Walking;
		//log(class$" Landed at speed "$velocity.Z);
		//log ("Playing "$AnimSequence);
		bJustLanded = true;
		if (Velocity.Z < -1 * JumpZ - 50)
			{
			////log("Play Landed");
			PlayLanded();
			Acceleration = vect(0,0,0);
			GotoState('Roaming', 'ResumeRoam');
			}
		else 
			{
			TweenToWalking(0.1);
			GotoState('Roaming', 'ContinueRoam');
			}
	}

function EnemyAcquired()
	{
	//log(Class$" just acquired an enemy");
	GotoState('Acquisition');
	}

function PickDestination()
{
	local CreaturePoint path;
	if (actorReachable(OrderObject))
		OrderObject = FindRandomDest();

	if (OrderObject != None)
		path = FindPathToward(OrderObject);
	else
		path = None;
		
	if (path != None)
		{
		MoveTarget = path;
		Destination = path.Location;
		}
	else 
		{
		//log(class$" stopped roaming");
		GotoState('Waiting');
		}
}

Begin:
	Alertness = 0.0;
	bReadyToAttack = false;
	//log(class$" Roaming");

Roam: //FIXME -add stasis mode? - also set random start point in roam area
	//FIXME - use routing to make roam successful
	//FIXME - walk (1/3 speed), don't run
	NextAnim = '';
	TweenToWalking(0.3);
	FinishAnim();
	PlayWalking();
	PickDestination();
	
Moving:
	MoveToward(MoveTarget, 0.4);
	Acceleration = vect(0,0,0);
	TweenToPatrolStop(0.4);
	FinishAnim();
	NextAnim = '';
	PlayPatrolStop();
	FinishAnim();
	Goto('Roam');

ResumeRoam:
	FinishAnim();
	TweenToWalking(0.25);

ContinueRoam:
	FinishAnim();
	PlayWalking();
	Goto('Moving');
}

State Patroling
{
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Acquisition'; 
		NextLabel = 'Begin';
		GotoState('TakeHit'); 
		}
	else if (Enemy != None)
		{
		LastSeenPos = Enemy.Location;
		GotoState('Acquisition');
		}

	}

function Bump(actor Other)
{
	//log(Other.class$" bumped "$class);
	if (Enemy == Other)
		{
		bReadyToAttack = True; //can melee right away
		GotoState('Attacking');
		}
	if (Pawn(Other) != None)
		if (SetEnemy(Pawn(Other)))
			LastSeenPos = Enemy.Location;
	setTimer(2.0, false);
	Disable('Bump');
}

//SeepLayer here - because don't enable AnimEnd in it
function SeePlayer(Actor SeenPlayer)
{
	//Check if in FOV
	//log(class$" has line of sight to player");
	
	if (int(Pawn(SeenPlayer).Health) > 0)
		{
		if (InFieldOfView(SeenPlayer))
			{
			//log(class$" sees player!");
			if (SetEnemy(Pawn(SeenPlayer)))
				LastSeenPos = SeenPlayer.Location;
			}
		}
}

function Timer()
{
	Enable('Bump');
}

function AnimEnd()
{
	PlayPatrolStop();
}

function EnemyAcquired()
	{
	//log(Class$" just acquired an enemy");
	GotoState('Acquisition');
	}

function PickDestination()
	{
	local CreaturePoint path;
	
	path = FindPathToward(OrderObject);
	if (path != None)
		{
		MoveTarget = path;
		Destination = path.Location;
		}
	else
		OrderObject = None;
	}
	
Begin:
	NextAnim = '';
	Alertness = 0.0;
	bReadyToAttack = false;
	//log(class$" Patroling");
	sleep(0.3);

Patrol: //FIXME -add stasis mode? - also set random start point in roam area
	Broadcast('', class 'Patrolpoint').TellAboutTo(Self);
	Disable('AnimEnd');
	if (PatrolPoint(OrderObject) != None)
		{
		////log("Move to next patrol point");
		TweenToWalking(0.3);
		FinishAnim();
		PlayWalking();

MoveToPatrol:
		if (actorReachable(OrderObject))
			MoveToward(OrderObject, 0.4);
		else
			{
			PickDestination();
			if (OrderObject != None)
				{
				MoveToward(MoveTarget, 0.4);
				Goto('MoveToPatrol');
				}
			else
				Goto('GiveUp');
			}
		
		////log("Got to patrol point "$OrderTag);	
		OrderTag = (Patrolpoint(OrderObject)).Nextpatrol;
		////log("Next patrol point "$OrderTag);	
		if ((Patrolpoint(OrderObject)).pausetime > 0.0)
			{
			////log("Pause patrol");
			Acceleration = vect(0,0,0);
			TweenToFighter(0.3);
			FinishAnim();
			PlayTurning();
			TurnTo(Location + (Patrolpoint(OrderObject)).lookdir);
			TweenToPatrolStop(0.3);
			FinishAnim();
			Enable('AnimEnd');
			NextAnim = '';
			PlayPatrolStop();
			////log("stop here for "$(Patrolpoint(OrderObject)).pausetime);
			Sleep((Patrolpoint(OrderObject)).pausetime);
			Disable('AnimEnd');
			FinishAnim();
			}
		Goto('Patrol');
		}

GiveUp:
		////log("gave up patrol");		
		TweenToPatrolStop(0.3);
		FinishAnim();
		Enable('AnimEnd');
		PlayPatrolStop();
}

state Guarding
{
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Acquisition'; 
		NextLabel = 'Begin';
		GotoState('TakeHit'); 
		}
	else if (Enemy != None)
		{
		LastSeenPos = Enemy.Location;
		GotoState('Acquisition');
		}
	}

function Bump(actor Other)
{
	//log(Other.class$" bumped "$class);
	if (Enemy == Other)
		bReadyToAttack = True; //can melee right away
	if (Pawn(Other) != None)
		if (SetEnemy(Pawn(Other)))
			LastSeenPos = Enemy.Location;
	setTimer(2.0, false);
	Disable('Bump');
}

function Timer()
{
	Enable('Bump');
}

function EnemyAcquired()
	{
	//log(Class$" just acquired an enemy");
	GotoState('Acquisition');
	}

function AnimEnd()
	{
	Disable('AnimEnd');
	PlayWaitingGuard();
	}

function PickDestination()
	{
	local CreaturePoint path;
	
	Destination = 0.5 * (Location + OrderObject.Location);
	if (!pointReachable(Destination))
		{
		path = FindPathTo(Destination);
		if (path != None)
			{
			MoveTarget = path;
			Destination = path.Location;
			}
		else
			GotoState('Guarding', 'Turn');
		}
	}
	
ResumeGuarding: //get back in position to guard OrderObject
	NextAnim = '';
	if (LineOfSightTo(OrderObject))
		if (size(Location - OrderObject.Location) < CollisionRadius + OrderObject.CollisionRadius + 200)
			Goto('Turn');

	Disable('AnimEnd');
	TweenToWalking(0.3);
	FinishAnim();
	PlayWalking();
	PickDestination();			
	MoveToward(MoveTarget, 0.4);
	Acceleration = vect(0,0,0);
	Goto('ResumeGuarding');
	
Turn:
	Disable('AnimEnd');
	TweenToFighter(0.3);
	if (bool(Enemy))
		{
		FinishAnim();
		PlayTurning();
		TurnTo(LastSeenPos);
		}
Begin:
	NextAnim = '';
	Disable('AnimEnd');
	Alertness = 0.0;
	bReadyToAttack = false;
	//log(class$" Guarding"$OrderObject.class);
	Enemy = None;
	TweenToPatrolStop(0.3);
	FinishAnim();
	Enable('AnimEnd');
	NextAnim = '';
	PlayWaitingGuard();
	DesiredRotation = rot(0,0,0);
	DesiredRotation.Yaw = Rotation.Yaw;
	setRotation(DesiredRotation);
	if (Physics != PHYS_Falling) Physics = PHYS_None;

}

state Ambushing
{
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Attacking'; 
		NextLabel = 'SetAttackTimer';
		GotoState('TakeHit'); 
		}
	else if (Enemy != None)
		{
		LastSeenPos = Enemy.Location;
		GotoState('Attacking');
		}
	}

function Landed()
	{
		Physics = PHYS_None;
		//log(class$" Landed");
	}

function Bump(actor Other)
{
	//log(Other.class$" bumped "$class);
	if (Enemy == Other)
		bReadyToAttack = True; //can melee right away
	if (Pawn(Other) != None)
		if (SetEnemy(Pawn(Other)))
			LastSeenPos = Enemy.Location;
	setTimer(2.0, false);
	Disable('Bump');
}

function Timer()
{
	Enable('Bump');
}

function AnimEnd()
	{
	Disable('AnimEnd');
	PlayWaitingAmbush();
	}
	
function EnemyAcquired()
	{
	local Ambushpoint oldspot;

	//log(Class$" just acquired an enemy");
	MakeNoise(1.0);
	oldspot = Ambushpoint(OrderObject);
	if (oldspot != None)
		oldspot.taken = false;
	Physics = PHYS_Walking;
	GotoState('Attacking');
	}

function Callback(object Other)
	{
	local Ambushpoint ambush;
	ambush = Ambushpoint(Other);
	if (!ambush.taken)
		if (actorReachable(ambush))
			{
			count = count + 1;
			if (FRand() < 1/count)
				OrderObject = Actor(Other);
			}
	}
	
FindAmbushSpot:
	//count = 1; //current location counts
	//OrderObject = None; //clear old ambush point
	//if ((Enemy == None) || (FRand() < 0.7))
	//	Broadcast('', class 'Ambushpoint').Callme(Self);

Begin:
	NextAnim = '';
	Disable('AnimEnd');
	
	//FIXME - make sure I clear my enemy before doing anything else (put in oldenemy)
//	if (OrderObject != None)
//		{
		////log("move to ambush spot");
		//Ambushpoint(OrderObject).taken = true;
		//Physics = PHYS_Walking;
		//TweenToRunning(0.3);
		//FinishAnim();
		//PlayRunning();
		//MoveToward(OrderObject);
//		Acceleration = vect(0,0,0);
//		DesiredSpeed = 0.0;
//		TweenToFighter(0.2);
//		FinishAnim();
//		PlayTurning();
//		TurnTo(Location + (Ambushpoint(OrderObject)).lookdir);
//		}
//	else 
	if (Enemy != None)
		{
		////log("turn toward probably enemy dir");
		OldEnemy = Enemy;
		Enemy = None;
		Physics = PHYS_Walking;
		if (Physics != PHYS_Falling)
			Acceleration = vect(0,0,0);
		DesiredSpeed = 0.0;
		TweenToFighter(0.2);
		FinishAnim();
		PlayTurning();
		TurnTo(LastSeenPos); //FIXME - turn to a nearby pathnode?
		}
	
	DesiredSpeed = 0.0;
	Alertness = 1.0;
	bReadyToAttack = true;
	//log(class$" waiting in ambush");
	TweenToPatrolStop(0.3);
	FinishAnim();
	Enable('AnimEnd');
	NextAnim = '';
	PlayWaitingAmbush();
	DesiredRotation = rot(0,0,0);
	DesiredRotation.Yaw = Rotation.Yaw;
	setRotation(DesiredRotation);
	if (Physics != PHYS_Falling) Physics = PHYS_None;

}
	
/* Acquisition - 
Creature has just reacted to stimulus, and set an enemy
- depending on strength of stimulus, and ongoing stimulii, vary time to focus on target and start attacking (or whatever.  FIXME - need some acquisition specific animation
HearNoise and SeePlayer used to improve/change stimulus
*/

state Acquisition
{
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Attacking'; 
		NextLabel = 'SetAttackTimer';
		GotoState('TakeHit'); 
		}
	else
		{
		LastSeenPos = Enemy.Location;
		GotoState('Attacking', 'SetAttackTimer');
		}
	}

function HearNoise(float Loudness, Actor NoiseMaker)
{
	local float OldStimulus;
	local rotation HearingError;

	OldStimulus = Stimulus;
	if(NoisePerceived(NoiseMaker,Loudness))
		{
		if (Stimulus > OldStimulus)
			{
			HearingError = rotation(NoiseMaker.Location - Location);
			HearingError.Yaw = HearingError.Yaw + (16384 - 8192 * FRand())/FMax(stimulus, 0.5);

			if (Pawn(NoiseMaker) != None)
				{
				if (SetEnemy(Pawn(NoiseMaker)))
					{
					if (Enemy == Pawn(NoiseMaker))
						LastSeenPos = Location + 150.0 * vector(HearingError);
					else if (Enemy == Pawn(NoiseMaker).Enemy)
						LastSeenPos = 0.5 * (Pawn(NoiseMaker).Enemy.Location + Location + 150 * vector(HearingError));
					else 
						LastSeenPos = Location + 150.0 * vector(HearingError);
					}
				}				
			else if (NoiseMaker.instigator != None)
				{
				if (SetEnemy(NoiseMaker.instigator))
					LastSeenPos = NoiseMaker.Location + 150.0 * vector(HearingError);
				}				
			} 
		else  Stimulus = OldStimulus;			
		}
}

function SeePlayer(Actor SeenPlayer)
{
	local float OldStimulus;

	OldStimulus = Stimulus;
		
	if (int(Pawn(SeenPlayer).Health) > 0)
		{  
		InFieldOfView(SeenPlayer);
		if ((Stimulus > 0.0) && (Stimulus > OldStimulus))
			{
			if (SetEnemy(Pawn(SeenPlayer)))
				LastSeenPos = SeenPlayer.Location;
			}
		else 
			Stimulus = OldStimulus;
		}
} 

// look for enemy in another direction
function TryNewDirection()
{
	local rotation newRot;
	
	newRot = Rotation;
	newRot.Yaw += Rand(16384) - 8192; //fixme - base on difficulty
	LastSeenPos = 200 * vector(newRot);
}

PlayOut:
	FinishAnim();
		
Begin:
	Physics = PHYS_Walking;

	if (Stimulus > 0.8)
		{ 
		MakeNoise(1.0);
		LastSeenPos = Enemy.Location; 
		////log("Enemy Acquired!");
		NextAnim = '';
		GotoState('Attacking', 'SetAttackTimer');
		}
	
	Acceleration = vect(0,0,0);
	TweenToFighter(0.2 + 0.3*FRand()); //FIXME - base speed on difficulty
	Alertness = -0.5; //acquire only when extremely visible //FIXME - back to -1.0?
	////log("Acquiring enemy");
	////log("Enemy position = "$Enemy.Location);
	////log("Last seen position = "$LastSeenPos);
	if (NeedToTurn(LastSeenPos))
	{	
		PlayTurning();
		TurnTo(LastSeenPos);
	}
	DesiredRotation = rotation(LastSeenPos - Location);
	FinishAnim();	
	////log("Focus = "$Focus);
	////log("Stimulus = "$Stimulus);
	if (LineOfSightTo(Enemy))
		{
		If (InFieldOfView(Enemy))
			{ 
			LastSeenPos = Enemy.Location; 
			////log("Enemy Acquired!");
			MakeNoise(1.0);
			NextAnim = '';
			GotoState('Attacking', 'SetAttackTimer');
			}
		else
			{
			TryNewDirection();
			Goto('Begin');
			}
		}
	else
		{
		if (AttitudeTo(Enemy) == ATTITUDE_Fear)  //will run away from noise
			{
			////log("Run away from noise");
			MakeNoise(1.0);
			NextAnim = '';
			GotoState('Attacking', 'SetAttackTimer');
			}
		else if (CombatStyle + Aggressiveness < 0.0)
			{
			////log("try to ambush noisemaker");
			PlayTurning();
			TurnTo(0.5 * (Enemy.Location + LastSeenPos));
			GotoState('Ambushing', 'FindAmbushSpot');

			}
		else if ((Intelligence > BRAINS_Reptile) && (FRand() > 0.5)) 
			{ //smart, aggressive creatures may ambush or investigate
			////log("ambush noisemaker");
			PlayTurning();
			TurnTo(LastSeenPos);
			GotoState('Ambushing', 'FindAmbushSpot');
			}
		else //investigate noise
			{
			////log("investigate noise");
			if (pointReachable(LastSeenPos))
				{
				TweenToWalking(0.3);
				FinishAnim();
				PlayWalking();
				MoveTo(LastSeenPos, 0.4);
				Acceleration = vect(0,0,0);
				}
			TweenToFighter(0.3);
			FinishAnim();
			PlayTurning();
			TurnTo(0.5 * (Enemy.Location + LastSeenPos));
			LastSeenPos = Enemy.Location;
			Goto('Begin');
			}
		}
}

/* Attacking
Master attacking state - choose which type of attack to do from here
*/
state Attacking
{
ignores SeePlayer, HearNoise, Bump, HitWall;

function ChooseAttackMode()
	{
	local bool bFoundState;
	local eAttitude AttitudeToEnemy;
	local float Aggression;
	bFoundState = false;
	AttitudeToEnemy = AttitudeTo(Enemy);

	//play transition from base attack position to appropriate for chosen attack state
	if ((Enemy == None) || (int(Enemy.Health) <= 0))
		{
		bFoundState = true;
		if ((OldEnemy != None) && (int(OldEnemy.Health) > 0)) 
			{
			Enemy = OldEnemy;
			OldEnemy = None;
			GotoState('Hunting');
			}
		else if (Orders == '')
			GotoState('Waiting');
		else
			GotoState(Orders);
		}
		
		
	else if (AttitudeToEnemy == ATTITUDE_Fear)
		{
		bFoundState = true;
		GotoState('Retreating');
		}

	else if (AttitudeToEnemy == ATTITUDE_Threaten)
		{
		bFoundState = true;
		GotoState('Threatening');
		}

	//FIXME - can I get enemy not visible info from function? not guaranteed?
	else if (!LineOfSightTo(Enemy))
		{
		bFoundState = true;
		if (Orders == 'Guarding')
			GotoState('Guarding', 'ResumeGuarding');
		else if (Aggressiveness + CombatStyle > FRand() - 1.0)
			{ //hunt, or if smart, decide if to ambush - FIXME also base on skill
		/*	if ((Intelligence > BRAINS_REPTILE) &&
				(RelativeStrength(Enemy) 
					> Aggressiveness + CombatStyle + 0.5))
				{
				GotoState('Ambushing', 'FindAmbushSpot');
				}
			else */
				GotoState('Hunting');
			}
		else
			GotoState('Ambushing', 'FindAmbushSpot');
		}	
	
	else if (bReadyToAttack)
		{
		bFoundState = true;
		bReadyToAttack = false;
		////log("Attack!");
		Target = Enemy;
		If (Size(Enemy.Location - Location) <= (MeleeRange + Enemy.CollisionRadius + CollisionRadius))
			GotoState('MeleeAttack');
		else if (bMovingRangedAttack)
			{
			bReadyToAttack = true;
			bFoundState = false;
			SetTimer(TimeBetweenAttacks, False);
			}
		else if (bHasRangedAttack)
			GotoState('RangedAttack');
		else
			{
			////log("can't attack");
			bReadyToAttack = true;
			bFoundState = false;
			}
		}
		
	if (!bFoundState) //decide whether to snipe, charge, or make a tactical move
		{
		Aggression = Aggressiveness + CombatStyle + 2 * FRand() - 1.0;
		if (!bHasRangedAttack) 
			Aggression = 2.0;
		else if (Location.Z > Enemy.Location.Z + 140) //tactical height advantage
			Aggression -= 1.0;
		//FIXME - also base decision on enemy weapon, if human intelligence
		//FIXME - also check if enemy is retreating
		if (Aggression < 0.5) //Snipe or Tactical move, depending on skill level
			{ 
			if (bReadyToAttack && bHasRangedAttack) //also has moving ranged attack(see above)
				{
				bReadyToAttack = false;
				GotoState('RangedAttack');
				}
			else if (Frand() < 0.3) //FIXME- should be based on skill level (higher skills move more)
				GotoState('Sniping');
			else
				GotoState('TacticalMove');
			}
		else //charge!
			GotoState('Charging');
		}
	}

//EnemyNotVisible implemented so engine will update LastSeenPos
function EnemyNotVisible()
	{
	////log("enemy not visible");
	}

function Timer()
	{
	bReadyToAttack = True;
	}

SetAttackTimer:
	SetTimer(TimeBetweenAttacks  * (1.0 + FRand()),false); //FIXME vary based on skill level
	
Begin:
	//log(class$" choose Attack");
	if (Physics == PHYS_None)
		Physics = PHYS_Walking; //FIXME - where is this not set right?
	ChooseAttackMode();
}

state Threatening
{
//ignores SeePlayer if enemy is a player //but not hear noise
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		bReadyToAttack = true;
		NextState = 'Attacking'; 
		NextLabel = 'Begin';
		GotoState('TakeHit'); 
		}
	else
		{
		bReadyToAttack = true;
		GotoState('Attacking');
		}
	}

function EnemyNotVisible()
	{
	////log("enemy not visible");
	GotoState('Ambushing'); 
	}

function EnemyAcquired()
	{
	if (AttitudeTo(Enemy) < ATTITUDE_Threaten)
		GotoState('Attacking');
	}
	
function PickGuardDestination()
	{
	local vector desiredDest;
	local CreaturePoint path;
	
	desiredDest = OrderObject.Location + 
			(OrderObject.CollisionRadius + 2.5 * CollisionRadius) * Normal(Enemy.Location - OrderObject.Location);

	if (pointReachable(desiredDest))
		Destination = desiredDest;
	else
		{
		path = FindPathTo(desiredDest, 2);
		if (path != None)
			{
			MoveTarget = path;
			Destination = path.Location;
			}
		else
			Destination = Location;
		}
	}
	
function PickThreatenDestination()
	{
	local vector desiredDest;
	local CreaturePoint path;

	desiredDest = Location + 
			0.4 * (Size(Enemy.Location - Location) - CollisionRadius - Enemy.CollisionRadius - MeleeRange)
			* Normal(Enemy.Location - Location);

	if (pointReachable(desiredDest))
		Destination = desiredDest;
	else
		{
		path = FindPathTo(desiredDest, 2);
		if (path != None)
			{
			MoveTarget = path;
			Destination = path.Location;
			}
		else
			Destination = Location;
		}
	}
	
Begin:
	bReadyToAttack = true;
	if (Enemy.bIsPlayer)
		Disable('SeePlayer'); //but not hear noise
	TweenToPatrolStop(0.2);
	FinishAnim();
	NextAnim = '';
	
FaceEnemy:
	if (NeedToTurn(enemy.Location))
		{	
		TweenToFighter(0.2);
		FinishAnim();
		PlayTurning();
		TurnToward(Enemy);
		TweenToPatrolStop(0.2);
		FinishAnim();
		NextAnim = '';
		}

	DesiredRotation = rotation(Enemy.Location - Location);	
		
Threaten:
	if (AttitudeTo(Enemy) < ATTITUDE_Threaten)
		GotoState('Attacking');

	PlayThreatening();
	FinishAnim();

	if (AttitudeTo(Enemy) < ATTITUDE_Threaten)
		GotoState('Attacking');
		
	if (Orders == 'Guarding')
		{ //stay between enemy and guard object
		If (Enemy.bIsPlayer &&
			(Size(Enemy.Location - OrderObject.Location) < OrderObject.CollisionRadius + 3 * CollisionRadius + MeleeRange))
				{
				AttitudeToPlayer = ATTITUDE_Hate;
				GotoState('Attacking', 'SetAttackTimer');
				}
		}
	else if (FRand() < 0.9 - Aggressiveness) //mostly just turn
		Goto('FaceEnemy');
	else if (Size(Enemy.Location - Location) < 2.5 * (CollisionRadius + Enemy.CollisionRadius + MeleeRange))
		Goto('FaceEnemy');

	if (Orders == 'Guarding') //stay between enemy and guard object
		PickGuardDestination();
	else
		PickThreatenDestination();
		
	if (Destination != Location)
		{
		TweenToWalking(0.2);
		FinishAnim();
		PlayWalking();
		MoveTo(Destination, 0.4);
		Acceleration = vect(0,0,0);
		TweenToPatrolStop(0.2);
		FinishAnim();
		NextAnim = '';
		}
		
	Goto('FaceEnemy');
}

state Retreating
{
ignores SeePlayer, HearNoise, Bump;

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'Retreating'; 
		NextLabel = 'TakeHit';
		GotoState('TakeHit'); 
		}
	}

function HitWall(vector HitNormal)
{
	local vector desiredDir;
	
	desiredDir = Normal(Enemy.Location - Location);
	if ((desiredDir dot HitNormal) < -0.9)
	{
		//log ("adjust from wall");
		Disable('HitWall');	
		MoveTimer = -1.0;
	}
}

function Timer()
	{
	bReadyToAttack = True;
	}
	
singular function Falling()
	{
		Physics = PHYS_Falling;
		if (JumpZ <= 0.0) //doesn't want to jump
			{
			if ((Normal(Velocity) Dot Normal(Destination - Location)) > 0.9)
				{
				log("Stopped at edge!");
				SetLocation(OldLocation);
				Velocity = vect(0,0,0);
				Acceleration = vect(0,0,0);
				MoveTimer = -1.0;
				}
			}
		else
			{
			Disable('HitWall');
			AdjustJump();
			PlayInAir();
			}

	}

function Landed()
	{
		Physics = PHYS_Walking;
		bJustLanded = true;
		if (Velocity.Z < -1 * JumpZ - 50)
			{
			PlayLanded();
			Acceleration = vect(0,0,0);
			GotoState('Retreating', 'ResumeRetreat');
			}
		else 
			{
			TweenToRunning(0.1);
			GotoState('Retreating', 'NoLanding');
			}
	}

/* if has a base then run toward it if its not visible to player. (FIXME)
//remember to adjust attitude based on proximity to base
Else pick a random pathnode not visible to player and run toward it.
Also - modify weights of paths visible and near to player up.
*/
function PickDestination()
	{
		Target = home;
		count = 0;
		if (Target == None)
			{
			Target = FindRandomDest();
			if (Target == None)
				{
				if (bReadyToAttack)
					{
					bReadyToAttack = false;
					setTimer(3.0, false);
					Target = Enemy;
					GotoState('RangedAttack');
					}
				else
					GotoState('TacticalMove', 'AlreadyMoving');
				}
			}
	}

function PickNextSpot()
	{
		local CreaturePoint path;
		local actor oldTarget;
		local vector dist2d;
		local float zdiff;

		dist2d = Target.Location - Destination;
		zdiff = dist2d.Z;
		dist2d.Z = 0.0;	
		if ((size(dist2d) < 2 * CollisionRadius) && (Abs(zdiff) < CollisionHeight))
			{
			if (LineOfSightTo(Enemy))
				{
				if (Target == home)
					{
					//log(class$" reached home base - turn and fight");
					Aggressiveness += 0.5;
					GotoState('Attacking');
					}
				else
					{
					oldTarget = Target;
					PickDestination();
					if (Target == oldTarget)
						GotoState('TacticalMove');
					else
						{
						path = FindPathToward(Target);
						if (path == None)
							GotoState('TacticalMove');
						else 
							{
							MoveTarget = path;
							Destination = path.Location;
							}
						}
					}
				}
			else
				{
				aggressiveness += 0.1;
				GotoState('Ambushing', 'FindAmbushSpot');
				}	
			}
		else
			{
			if (ActorReachable(Target))
				path = CreaturePoint(Target);
			else
				path = FindPathToward(Target);
				
			if (path == None)
				{
				PickDestination();
				FindPathToward(Target);
				if (path == None)
					GotoState('TacticalMove');
				else
					{
					MoveTarget = path;
					Destination = path.Location;
					}
				}
			else
				{
				MoveTarget = path;
				Destination = path.Location;
				}
			}
		
	}

Begin:
	//then stop being afraid - also heal slowly at base
	//FIXME - have higher skill/IQ creatures strafe backwards, while firing
	if (bReadyToAttack)
		if (FRand() < 0.6)
			{
			SetTimer(TimeBetweenAttacks, false);
			bReadyToAttack = false;
			}
	TweenToRunning(0.2);
	FinishAnim();
	PlayRunning();
	PickDestination();
	
RunAway:
	Enable('HitWall');
	PickNextSpot();
Moving:
	MoveToward(MoveTarget); 
	Goto('RunAway');

ResumeRetreat:
	FinishAnim();
	TweenToRunning(0.25);
NoLanding:
	FinishAnim();
	PlayRunning();
	Enable('HitWall');
	Goto('RunAway');

TakeHit:
	TweenToRunning(0.2);
	FinishAnim();
	PlayRunning();
	Goto('Moving');
}

state Charging
{
ignores SeePlayer, HearNoise;

function HitWall(vector HitNormal)
{
	local actor HitActor;
	
	if ((Normal(Destination - Location) dot HitNormal) < -0.85)
		{
		//log ("adjust from wall");
		Disable('HitWall');	
		MoveTimer = -1.0;
		bFromWall = true;
		}
}

function Bump(Actor Other)
{
	if (Other == Enemy)
		{
		Disable('Bump');
		Disable('HitWall');
		GotoState('Charging', 'GotThere');
		}
	else if (int(Enemy.Health) <= 0)
		{
		Disable('Bump');
		Disable('HitWall');
		GotoState('Attacking');
		}
}

singular function Falling()
	{
		Physics = PHYS_Falling;
		if (JumpZ <= 0.0) //doesn't want to jump
			{
			if ((Normal(Velocity) Dot Normal(Destination - Location)) > 0.9)
				{
				//log("Stopped at edge!");
				SetLocation(OldLocation);
				Velocity = vect(0,0,0);
				Acceleration = vect(0,0,0);
				MoveTimer = -1.0;
				if (Intelligence == BRAINS_Reptile)
					GotoState('Sniping');
				}
			}
		else
			{
			Disable('AnimEnd');
			NextAnim = 'Landed';
			AdjustJump();
			PlayInAir();
			}
	
	}

function Landed()
	{
		Physics = PHYS_Walking;
		//log(class$" Landed at speed "$velocity.Z);
		bJustLanded = true;
		if (Velocity.Z < -1 * JumpZ - 50)
			{
			////log("Play Landed");
			PlayLanded();
			Acceleration = vect(0,0,0);
			Enable('Bump');
			GotoState('Charging', 'ResumeCharge');
			}
		else 
			{
			//TweenToRunning(0.1); //only when really playing inair()
			Enable('HitWall');
			//Enable('AnimEnd');
			}
	}

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		if (AttitudeTo(Enemy) == ATTITUDE_Fear)
			{
			NextState = 'Retreating';
			NextLabel = 'Begin';
			}
		else
			{
			NextState = 'Charging';
			NextLabel = 'TakeHit';
			}
		GotoState('TakeHit'); 
		}
	}
						
function AnimEnd() 
	{
	if (NextAnim == 'Charging')
		{
		PlayRunning();
		Disable('AnimEnd');
		}
	else
		PlayMovingAttack();
	}

function Timer()
	{
	bReadyToAttack = True;
	
	if (Size(Enemy.Location - Location) 
			<= (MeleeRange + Enemy.CollisionRadius + CollisionRadius))
		{ 
		////log("Got to enemy");
		Disable('HitWall');
		GotoState('Attacking');
		}

	else if (bMovingRangedAttack && (FRand() < 0.8) && (MoveTarget == Enemy)) //FIXME - make decision skill based
		{
		NextAnim = 'MovingAttack';
		Enable('AnimEnd');
		}
	else if (bHasRangedAttack)
		{ 
		if (Aggressiveness + CombatStyle > Frand() + FRand()) //then keep charging
			SetTimer(1.5,false); 
		else
			{
			Disable('HitWall');
			GotoState('Attacking');
			}
		}
	}

function EnemyNotVisible()
	{
	//log("enemy not visible");
	if ((Intelligence > BRAINS_None) || (MoveTimer < 0.5))
		GotoState('Hunting'); 
	}


function PickDestination()
	{
	local CreaturePoint path;
	local bool success;
	
 	success = FindBestPathToward(Enemy); 
			
	if (!success)
		{
		Disable('HitWall');
		//log("Give up charge");
		if (FRand() < 0.5)
			GotoState('Sniping');
		else
			GotoState('TacticalMove');
		}
	}	

ResumeCharge:
	Disable('AnimEnd');
	FinishAnim();
	TweenToRunning(0.2);
	FinishAnim();
	Enable('HitWall');
	PlayRunning();
	Goto('Charge');
	
Begin:
	Disable('HitWall');
	Disable('AnimEnd');
	TweenToRunning(0.2);
	FinishAnim();
	bFromWall = false;
	//log(class$ " charging");
	PlayRunning();	

Charge:
	Enable('AnimEnd');
	NextAnim = 'Charging';
	//log("Charge!");
	
CloseIn:
	Enable('HitWall');
	If(actorReachable(Enemy) || (Intelligence == BRAINS_Reptile))
		{
		if (bReadyToAttack && bMovingRangedAttack)
			NextAnim = 'MovingAttack';
		//log("Straight in to "$Enemy.class);
		MoveToward(Enemy);
		}
	else
		{
		PickDestination();
		if (Size(MoveTarget.Location - Location) < 3 * CollisionRadius)
			StrafeFacing(MoveTarget.Location, Enemy); //FIXME - need a 2 actor StrafeTowardFacing()
		else
			MoveToward(MoveTarget);
		}
	//log("finished move");
	if (Size(Location - Enemy.Location) < CollisionRadius + Enemy.CollisionRadius + MeleeRange)
		Goto('GotThere');
	MoveTimer = 0.0;
	Goto('CloseIn');

GotThere:
	////log("Got to enemy");
	bReadyToAttack = true;
	Target = Enemy;
	GotoState('MeleeAttack');

TakeHit:
	TweenToRunning(0.1);
	FinishAnim();
	PlayRunning();
	if (MoveTarget == Enemy)
		MoveToward(MoveTarget);
	
	Goto('Charge');
}

state TacticalMove
{
ignores SeePlayer, HearNoise, Bump;

//FIXME - shouldn't leave tactical move always on take hit

function HitWall(vector HitNormal)
{
	local float reachdist;
	local vector desiredDir, enemyDir, pickdir;
	
	desiredDir = Normal(Destination - Location);
	if ((desiredDir dot HitNormal) < -0.5)
		{
		////log("Hit wall in tactical move");
		GotoState('Attacking');
		}
}

function AnimEnd() 
	{
	local float dir;
	local vector Focus2D, Loc2D, Dest2D;
	local vector X,Y,Z;
	GetAxes(Rotation,X,Y,Z);
	Focus2D = Focus;
	Focus2D.Z = 0;
	Loc2D = Location;
	Loc2D.Z = 0;
	Dest2D = Destination;
	Dest2D.Z = 0;
	
	dir = Normal(Focus2D - Loc2D) dot Normal(Dest2D - Loc2D);
	if (dir > 0.9)
		PlayRunning();
	else if (dir < -0.9)
		PlayRetreating();
	else if ((Y Dot (Dest2D - Loc2D)) > 0) 
		PlayStrafeLeft(); 
	else
		PlayStrafeRight();
	}

function Timer()
	{
	bReadyToAttack = True;
//	if (bStrafingRangedAttack && (FRand() < 0.75)) //FIXME - make decision skill based
//		{
//		NextAnim = 'StrafingAttack'; //reset, so moving attack can use it
//		Enable('AnimEnd');
//		}
// else
	if (bHasRangedAttack || (Size(Enemy.Location - Location) 
			<= (MeleeRange + Enemy.CollisionRadius + CollisionRadius)))
		GotoState('RangedAttack');
	}

function EnemyNotVisible()
	{
	////log("enemy not visible");
	GotoState('Attacking');
	}

/* PickDestination()
Choose a destination for the tactical move, based on aggressiveness and the tactical
situation. Make sure destination is reachable
FIXME - if enemy reachable, don't jump down to non-reachable location 
maybe never jump down below enemy unless he's reachable from destination
*/
function PickDestination()
	{
	local vector pick, pickdir, enemydir,X,Y,Z, minDest;
	local float aggression, realJump;
	local bool success;
	GetAxes(Rotation,X,Y,Z);
	
	enemydir = Normal(Enemy.Location - Location);
	aggression = Aggressiveness + CombatStyle + 2.0 * FRand() - 1.0;
	if (Location.Z < Enemy.Location.Z - CollisionHeight)
		{
		if (size(Location - Enemy.Location) < 4 * (Enemy.Location.Z - Location.Z)) 
			if (!actorReachable(Enemy))
				{
				////log("back off");
				aggression = -1.5 * FRand();
				}
		}
				
	enemydir = enemydir * aggression * 0.4;
	pickdir = Normal((2 * FRand() - 1) * Y);
	pick = Location + (pickdir + enemydir) * (4 * CollisionRadius + 400 * FRand());
	pick.Z = Location.Z;
	minDest = Location + 4 * CollisionRadius * pickdir; 
	//FIXME - what I really want to do is make sure if the enemy is reachable now that he is
	//still reachable in the new location - need to know exactly what destination will be
	realJump = JumpZ;
	JumpZ = -1.0;
	if (pointReachable(minDest))
		{
		success = true;
		Destination = pick;	
		}
	JumpZ = realJump;
					
	if (!success)
		{
		pick = Location + (enemydir - pickdir) * (4 * CollisionRadius + 400 * FRand());
		pick.Z = Location.Z;
		minDest = Location + 4 * CollisionRadius * pickdir; 
		//FIXME - what I really want to do is make sure if the enemy is reachable now that he is
		//still reachable in the new location - need to know exactly what destination will be
		JumpZ = -1.0;
		if (pointReachable(minDest))
			{
			success = true;
			Destination = pick;	
			}
		JumpZ = realJump;
		}
		
	if (!success)
		GotoState('Sniping'); //Never charge again (endless loop possible, with lots of findpaths)
		//FIXME - instead try third & fourth tactical moves as charge or retreat
	}

Begin:

	//log(class$ " moving tactically");
	TweenToRunning(0.2);
	Disable('AnimEnd');
	FinishAnim();
	TweenToRunning(0.05); //so AnimEnd will happen
	
AlreadyMoving:
	Enable('AnimEnd');
	PickDestination();
	
	if (!bCanStrafe) //FIXME - make skill based (and also based on angle of move)
		MoveTo(Destination);
	else
		{
		//log(class$ " is strafing");
		StrafeFacing(Destination, Enemy);	
		}
	
	if (FRand() < 0.9) 
		{
		//log(class$ "done with move");
		GotoState('Attacking');
		}
	else // possibility of multiple combined tacticalmoves (w/ no return to Attacking)
		Goto('AlreadyMoving');
}

state Sniping
{
ignores SeePlayer, HearNoise, Bump; //FIXME? don't ignore bump

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (AttitudeTo(Enemy) == ATTITUDE_Fear)
		{
		NextState = 'Retreating';
		NextLabel = 'Begin';
		}
	else
		{
		NextState = 'Sniping';
		NextLabel = 'Snipe';
		} 
	GotoState('TakeHit');
}

function Timer()
	{
	////log("Attack timer sprung in Sniping");
	bReadyToAttack = True;
	GotoState('RangedAttack');
	}

function EnemyNotVisible()
	{
	////log("enemy not visible");
	GotoState('Attacking');
	}
	
Begin:
	setTimer(0.4 * TimeBetweenAttacks, false);
	//log(class$ " sniping");
	
Snipe:
	Acceleration = vect(0,0,0);
	TweenToFighter(0.2);
	FinishAnim();

	if (NeedToTurn(enemy.Location))
	{
		PlayTurning();
		TurnToward(Enemy);
	}
	if (bReadyToAttack) 
		GotoState('RangedAttack');

	Goto('Snipe');
}

state Hunting
{
ignores Bump, HearNoise, EnemyNotVisible; //FIXME? don't ignore?

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		if (AttitudeTo(Enemy) == ATTITUDE_Fear)
			{
			NextState = 'Retreating';
			NextLabel = 'Begin';
			}
		else
			{
			NextState = 'Charging';
			NextLabel = 'TakeHit';
			}
		GotoState('TakeHit'); 
		}
	}

function HitWall(vector HitNormal)
{
	local vector desiredDir;
	
	desiredDir = Normal(Enemy.Location - Location);
	if ((desiredDir dot HitNormal) < -0.9)	
		{
		//log ("adjust from wall");
/*		if (MoveTarget == None) //then trying for lastseenpos
			{
			//FIXME - try to adjust from wall (new state)
			GotoState('Ambushing', 'FindAmbushSpot');
			} */	
		Disable('HitWall');	
		MoveTimer = -1.0;
		bFromWall = true;
		}
}

singular function Falling()
	{
		Physics = PHYS_Falling;
		if (JumpZ <= 0.0) //doesn't want to jump
			{
			if ((Normal(Velocity) Dot Normal(Destination - Location)) > 0.9)
				{
				log("Stopped at edge!");
				SetLocation(OldLocation);
				Velocity = vect(0,0,0);
				Acceleration = vect(0,0,0);
				MoveTimer = -1.0;
				if (MoveTarget == None) //then trying for lastseenpos
					GotoState('Ambushing', 'FindAmbushSpot');
				}
			}
		else
			{
			AdjustJump();
			PlayInAir();
			}
	}

function Landed()
	{
		Physics = PHYS_Walking;
		//log(class$" Landed at speed "$velocity.Z);
		//log ("Playing "$AnimSequence);
		bJustLanded = true;
		if (Velocity.Z < -1 * JumpZ - 50)
			{
			////log("Play Landed");
			PlayLanded();
			Acceleration = vect(0,0,0);
			GotoState('Hunting', 'ResumeHunt');
			}
		else 
			GotoState('Hunting');
	}

function bool SetEnemy(Pawn NewEnemy)
	{
	local bool result;
	result = false;
	if (CallGlobal.SetEnemy(NewEnemy))
		{
		result = true;
		if ((!bReadyToAttack) || (!bHasRangedAttack) || (CombatStyle > 0.5))
			GotoState('Charging', 'Charge'); 
		else
			GotoState('Attacking');
		}
	return result;
	} 

function Timer()
	{
	bReadyToAttack = true;
	}

function PickDestination()
	{
	local CreaturePoint path;
	local bool success;

	if (Enemy.Health <= 0)
		{
		Enemy = None;
		GotoState('Ambushing', 'FindAmbushSpot');
		}
	else if (intelligence != BRAINS_Reptile)
		{
		success = FindBestPathToward(Enemy); 
		if (!success)
			if (Intelligence < BRAINS_Human)
				GotoState('Ambushing', 'FindAmbushSpot');
			else
				GotoState('Hunting', 'PauseHunt');
		}
	else 
		{
		MoveTarget = None;
		Destination = LastSeenPos - Normal(Enemy.Location - Enemy.OldLocation) * CollisionRadius;
		}
	}	

Begin:
	//log(class$" Hunting"); //FIXME put a moveto here, with a seeplayer function above
	Alertness = 1.0;  //FIXME - reduce to 0.5? 
	TweenToRunning(0.2);
	FinishAnim();
	bFromWall = false;
	PlayRunning();
	
Follow:
	Enable('HitWall');
	PickDestination();
	if (MoveTarget == None)
		{
		LastSeenPos = Enemy.Location;
		MoveTo(Destination);
		}
	else
		MoveToward(MoveTarget); 
	Goto('Follow');

ResumeHunt:
	FinishAnim();
	TweenToRunning(0.2);
	FinishAnim();
	PlayRunning();
	Goto('Follow');

PauseHunt:
	DesiredRotation = rotation(Enemy.Location - Location);
	TweenToFighter(0.3);
	Sleep(0.8);
	if (FindBestPathToward(Enemy))
		{
		PlayRunning();
		Enable('HitWall');
		MoveToward(MoveTarget);
		}
	else
		GotoState('Ambushing', 'FindAmbushSpot');
	Goto('Follow');
}

state TakeHit //fixme need state TakeBigHit too
{
ignores falling, seeplayer, hearnoise, bump, hitwall;

function Timer()
{
	bReadyToAttack = true;
}

Begin:
	FinishAnim();
	//log("Next state = "$NextState$" NextLabel = "$NextLabel);
	if (NextState != '')
		GotoState(NextState, NextLabel);
	else
		GotoState('Attacking');
}
//MeleeAttack and RangedAttack are implemented in the subclasses
// Except that DamageTarget is inherited by all

state MeleeAttack
{
ignores SeePlayer, HearNoise, Bump;
/* DamageTarget
check if attack hit target, and if so damage it
*/
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'MeleeAttack';
		NextLabel = 'Begin';
		}
	}

function KeepAttacking()
	{
	if (Size(Target.Location - Location) > (0.9 * MeleeRange + Target.CollisionRadius + CollisionRadius)) 
		GotoState('Attacking', 'SetAttackTimer');
	else if (Target == None) 
		GotoState('Attacking', 'SetAttackTimer');
	else if (Pawn(Target) != None)
		{
		if (int(Pawn(Target).Health) == 0)
			GotoState('Attacking', 'SetAttackTimer');
		}
	}

function bool DamageTarget(int hitdamage, vector pushdir)
	{
	local vector HitLocation, HitNormal, TargetPoint;
	local float TargetDist;
	local actor HitActor;
	local bool result;
	
	result = false;
	TargetDist = Size(Target.Location - Location);
	If (TargetDist <= (MeleeRange * 1.4 + Target.CollisionRadius + CollisionRadius)) //still in melee range
		{
		TargetPoint = Location + TargetDist * vector(Rotation); 
		TargetPoint.Z = FMin(TargetPoint.Z, Target.Location.Z + Target.CollisionHeight);
		TargetPoint.Z = FMax(TargetPoint.Z, Target.Location.Z - Target.CollisionHeight);
		HitActor = Trace(HitLocation, HitNormal, TargetPoint, Location, true);
		If (HitActor == Target)
			{	
			Target.Damage(hitdamage, Self,HitLocation, pushdir);
			result = true;
			}
		}
	}

function EnemyNotVisible()
	{
	////log("enemy not visible");
	NextAnim = 'TakeHit'; //make sure melee animation completes
	GotoState('Attacking', 'SetAttackTimer');
	}

Begin:
	//log(class$" has no Melee Attack");
	GotoState('RangedAttack');
}

state RangedAttack
{
ignores SeePlayer, HearNoise;
/* RayDamageTarget
check if ray (instant) attack hit target, and if so damage it
If ranged attack uses projectile, its impact will trigger the damage
*/
function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
	{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextState == 'TakeHit')
		{
		NextState = 'RangedAttack';
		NextLabel = 'Begin';
		}
	}

function RayDamageTarget(int hitdamage, vector RayDir)
{
	local actor HitActor;
	local vector HitLocation, HitNormal, TargetPoint;
	
	TargetPoint = Location + RayDir * FMax(2000, Size(Target.Location - Location));
	
	HitActor = Trace(HitLocation, HitNormal, TargetPoint, Location, true);
	if( HitActor!=None && HitActor!=Level )
		 {
	 		////log("Ray from "$class$" hit "$target.class);
	 		Target.Damage(hitdamage, Self,HitLocation,
				(1000.0 * float(hitdamage) * (Normal(Target.Location - Location) + vect(0,0,1))));
		}
}

function EnemyNotVisible()
	{
	////log("enemy not visible");
	NextAnim = 'TakeHit'; //make sure attack animation completes
	GotoState('Attacking', 'SetAttackTimer');
	}

function KeepAttacking(float odds)
{
	If (FRand() > odds) //FIXME base on skill
		GotoState('Attacking', 'SetAttackTimer');
	else if (Target == None) 
		GotoState('Attacking', 'SetAttackTimer');
	else if (Pawn(Target) != None)
		{
		if (int(Pawn(Target).Health) == 0)
			GotoState('Attacking', 'SetAttackTimer');
		}
}

Begin:
	//log(class$" has no Ranged Attack");
	GotoState('Attacking');
}

state VictoryDance
{
ignores SeePlayer, HearNoise;

function HitWall(vector HitNormal)
{
	local vector desiredDir;
	
	desiredDir = Normal(Enemy.Location - Location);
	if ((desiredDir dot HitNormal) < -0.9)	
		{
		Disable('HitWall');
		MoveTimer = -1.0;
		}
}
	
function Bump(Actor Other)
	{
	if (Other == Enemy)
		{
		Disable('Bump');
		Disable('HitWall');
		Acceleration = Vect(0,0,0);
		GotoState('VictoryDance', 'Taunt');
		}
	}

function EnemyAcquired()
	{
	//log(Class$" just acquired an enemy");
	GotoState('Acquisition');
	}
	
function PickDestination()
	{
	local CreaturePoint path;
	local vector destpoint;
	destpoint = Enemy.Location;
	destpoint.Z += CollisionHeight - Enemy.CollisionHeight;
	if (pointReachable(destpoint))
	{
		MoveTarget = Enemy;
		Destination = destpoint;
	}
	else
		{
		path = FindPathToward(Enemy);
		if (path != None)
			{
			MoveTarget = path;
			Destination = path.Location;
			}
		else if (Orders == '')
			GotoState('Roaming'); 
		else
			GotoState(Orders);
		}
	}
	
Begin:
	If (Size(Location - Enemy.Location) < 
		(2 * CollisionRadius + Enemy.CollisionRadius + CollisionHeight - Enemy.CollisionHeight))
		Goto('Taunt');
	TweenToWalking(0.3);
	FinishAnim();
	PlayWalking();
	Enable('Bump');
		
MoveToEnemy:
	PickDestination();
	MoveToward(MoveTarget, 0.4);
	Enable('Bump');
	If (Size(Location - Enemy.Location) < 
		(2 * CollisionRadius + Enemy.CollisionRadius + CollisionHeight - Enemy.CollisionHeight))
		Goto('Taunt');
	Goto('MoveToEnemy');

Taunt:
	Acceleration = vect(0,0,0);
	Disable('Hitwall');
	TweenToFighter(0.3);
	//log(class$" Victory dance");
	DesiredRotation = rot(0,0,0);
	DesiredRotation.Yaw = Rotation.Yaw;
	setRotation(DesiredRotation);
	FinishAnim();
	Enemy.SetCollision(false,false,false); 
	PlayTurning();
	TurnToward(Enemy);
	TweenToFighter(0.2);
	FinishAnim();
	PlayVictoryDance();
	FinishAnim();
	Enemy = None;
	if (Orders == '')
		GotoState('Waiting'); 
	else
		GotoState(Orders);
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
   End DefaultProperties
End Class

Begin Class Name=Human
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Human.
//=============================================================================
class Human expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Female ANIVFILE=..\MODELS\Female_a.3D DATAFILE=..\MODELS\Female_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Female X=0 Y=30 Z=-50 YAW=64 ROLL=-64

#exec MESH SEQUENCE MESH=Female SEQ=All    STARTFRAME=0   NUMFRAMES=146
#exec MESH SEQUENCE MESH=Female SEQ=Walking STARTFRAME=0   NUMFRAMES=30
#exec MESH SEQUENCE MESH=Female SEQ=Death  STARTFRAME=30   NUMFRAMES=101
#exec MESH SEQUENCE MESH=Female SEQ=Shoot  STARTFRAME=131   NUMFRAMES=15

#exec TEXTURE IMPORT NAME=JFemale1 FILE=..\MODELS\Female.PCX FAMILY=Skins PALETTE=JFemale1 

#exec MESHMAP NEW   MESHMAP=Female MESH=Female
#exec MESHMAP SCALE MESHMAP=Female X=0.035 Y=0.035 Z=0.07

#exec MESHMAP SETTEXTURE MESHMAP=Female NUM=1 TEXTURE=JFemale1

#exec AUDIO IMPORT FILE="..\Sounds\Player\fyell1.UFX" NAME="FYell1" FAMILY="Player"
#exec AUDIO IMPORT FILE="..\Sounds\Player\fscrm1.UFX" NAME="Fscrm1" FAMILY="Player"
#exec AUDIO IMPORT FILE="..\Sounds\Player\fgrunt2.UFX" NAME="FGrunt2" FAMILY="Player"

//==================================================================================
//
// Animation

function PlayRunning()
	{
		//FIXME -check groundspeed, and play walk or run depending on speed
		LoopAnim('Walking', -1.0/GroundSpeed,true,0.3);
	}

function PlayDying()
	{
		PlayAnim('Death', 0.5);
		PlaySound(Sound 'FScrm1');
	}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      BaseEyeHeight=+00012.000000
      Bob=+00000.001000
      bLookUpStairs=True
      TimeBetweenAttacks=+00000.000000
      Visibility=128
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00400.000000
      WaterSpeed=+00000.000000
      AccelRate=+02048.000000
      JumpZ=+00260.000000
      MaxStepHeight=+00024.000000
      DrawType=DT_Mesh
      Mesh=Female
      CollisionRadius=+00018.000000
      CollisionHeight=+00030.000000
      LightBrightness=70
      LightHue=40
      LightSaturation=128
      LightRadius=6
      RotationSpeed=65535
   End DefaultProperties
End Class

Begin Class Name=Male
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Male.
//=============================================================================
class Male expands Human
	package(UnGame);

#exec MESH IMPORT MESH=Male ANIVFILE=..\MODELS\Male_a.3D DATAFILE=..\MODELS\Male_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Male X=0 Y=0 Z=0 YAW=64

#exec MESH SEQUENCE MESH=Male SEQ=All    STARTFRAME=0 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Male SEQ=Still  STARTFRAME=0 NUMFRAMES=1

#exec TEXTURE IMPORT NAME=JMale1 FILE=..\MODELS\Male.PCX FAMILY=Skins PALETTE=JMale1 
#exec MESHMAP NEW   MESHMAP=Male MESH=Male
#exec MESHMAP SCALE MESHMAP=Male X=0.032 Y=0.032 Z=0.064

#exec MESHMAP SETTEXTURE MESHMAP=Male NUM=1 TEXTURE=JMale1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      Mesh=Male
   End DefaultProperties
End Class

Begin Class Name=Female
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Female.
//=============================================================================
class Female expands Human
	package(UnGame);

#exec MESH IMPORT MESH=Female ANIVFILE=..\MODELS\Female_a.3D DATAFILE=..\MODELS\Female_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Female X=0 Y=30 Z=-50 YAW=64 ROLL=-64

#exec MESH SEQUENCE MESH=Female SEQ=All    STARTFRAME=0   NUMFRAMES=146
#exec MESH SEQUENCE MESH=Female SEQ=Walking STARTFRAME=0   NUMFRAMES=30
#exec MESH SEQUENCE MESH=Female SEQ=Death  STARTFRAME=30   NUMFRAMES=101
#exec MESH SEQUENCE MESH=Female SEQ=Shoot  STARTFRAME=131   NUMFRAMES=15

#exec TEXTURE IMPORT NAME=JFemale1 FILE=..\MODELS\Female.PCX FAMILY=Skins PALETTE=JFemale1 

#exec MESHMAP NEW   MESHMAP=Female MESH=Female
#exec MESHMAP SCALE MESHMAP=Female X=0.035 Y=0.035 Z=0.07

#exec MESHMAP SETTEXTURE MESHMAP=Female NUM=1 TEXTURE=JFemale1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
   End DefaultProperties
End Class

Begin Class Name=Brute
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Brute.
//=============================================================================
class Brute expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=BigMan ANIVFILE=..\Models\ANIV58.3D DATAFILE=..\Models\DATA58.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=BigMan X=0 Y=300 Z=-170 YAW=64

#exec MESH SEQUENCE MESH=BigMan SEQ=All          STARTFRAME=0   NUMFRAMES=411
#exec MESH SEQUENCE MESH=BigMan SEQ=StillLook    STARTFRAME=0   NUMFRAMES=50
#exec MESH SEQUENCE MESH=BigMan SEQ=StillFire    STARTFRAME=50  NUMFRAMES=20
#exec MESH SEQUENCE MESH=BigMan SEQ=PistolWhip   STARTFRAME=70  NUMFRAMES=20
#exec MESH SEQUENCE MESH=BigMan SEQ=Sleep        STARTFRAME=90  NUMFRAMES=30
#exec MESH SEQUENCE MESH=BigMan SEQ=FGutShot      STARTFRAME=120 NUMFRAMES=35
#exec MESH SEQUENCE MESH=BigMan SEQ=Die          STARTFRAME=155 NUMFRAMES=36
#exec MESH SEQUENCE MESH=BigMan SEQ=ShootLeft    STARTFRAME=191 NUMFRAMES=23
#exec MESH SEQUENCE MESH=BigMan SEQ=Walk         STARTFRAME=213 NUMFRAMES=45
#exec MESH SEQUENCE MESH=BigMan SEQ=WalkLeft     STARTFRAME=213 NUMFRAMES=22
#exec MESH SEQUENCE MESH=BigMan SEQ=WalkRight    STARTFRAME=235 NUMFRAMES=23
#exec MESH SEQUENCE MESH=BigMan SEQ=ShootRight   STARTFRAME=258 NUMFRAMES=22
#exec MESH SEQUENCE MESH=BigMan SEQ=Fighter      STARTFRAME=280 NUMFRAMES=1
#exec MESH SEQUENCE MESH=BigMan SEQ=T1           STARTFRAME=281 NUMFRAMES=24
#exec MESH SEQUENCE MESH=BigMan SEQ=T2           STARTFRAME=305 NUMFRAMES=19
#exec MESH SEQUENCE MESH=BigMan SEQ=T3           STARTFRAME=324 NUMFRAMES=16
#exec MESH SEQUENCE MESH=BigMan SEQ=T4           STARTFRAME=340 NUMFRAMES=15
#exec MESH SEQUENCE MESH=BigMan SEQ=T5           STARTFRAME=355 NUMFRAMES=5
#exec MESH SEQUENCE MESH=BigMan SEQ=TakeHit      STARTFRAME=360 NUMFRAMES=10
#exec MESH SEQUENCE MESH=BigMan SEQ=Die2         STARTFRAME=370 NUMFRAMES=41

#exec TEXTURE IMPORT NAME=BigMan1 FILE=..\Models\BigMan1.PCX FAMILY="Skins"
#exec TEXTURE IMPORT NAME=BigMan2 FILE=..\Models\BigMan2.PCX FAMILY="Skins" Palette=BigMan1

#exec MESHMAP NEW   MESHMAP=BigMan MESH=BigMan 
#exec MESHMAP SCALE MESHMAP=BigMan X=0.1 Y=0.1 Z=0.2

#exec MESHMAP SETTEXTURE MESHMAP=BigMan NUM=0 TEXTURE=BigMan1 
#exec MESHMAP SETTEXTURE MESHMAP=BigMan NUM=4 TEXTURE=BigMan2

#exec MESH NOTIFY MESH=BigMan SEQ=ShootLeft TIME=0.33 FUNCTION=SpawnLeftShot
#exec MESH NOTIFY MESH=BigMan SEQ=ShootRight TIME=0.39 FUNCTION=SpawnRightShot
#exec MESH NOTIFY MESH=BigMan SEQ=StillFire TIME=0.5 FUNCTION=SpawnLeftShot
#exec MESH NOTIFY MESH=BigMan SEQ=PistolWhip TIME=0.5 FUNCTION=WhipDamageTarget
#exec MESH NOTIFY MESH=BigMan SEQ=GutShot TIME=0.31 FUNCTION=GutShotTarget
#exec MESH NOTIFY MESH=BigMan SEQ=Walk TIME=0.31 FUNCTION=FootStep1
#exec MESH NOTIFY MESH=BigMan SEQ=Walk TIME=0.62 FUNCTION=FootStep2

#exec AUDIO IMPORT FILE="..\Sounds\Brute\death.UFX" NAME="death" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\growl1.UFX" NAME="Growl1" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\growl2.UFX" NAME="Growl2" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\growl4.UFX" NAME="Growl4" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\hit.UFX" NAME="Hit" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\footstep.UFX" NAME="footstep" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\Bigman1.UFX" NAME="Growl5" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\Bigman2.UFX" NAME="Growl3" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\monst13.UFX" NAME="Sleep" FAMILY="Brute"
#exec AUDIO IMPORT FILE="..\Sounds\Brute\bruteag.UFX" NAME="Seeplayer" FAMILY="Brute"


//-----------------------------------------------------------------------------
// Brute variables.

// Attack damage.
var() byte
	ShootDamage,	// Basic damage done by each shot.
	WhipDamage;		// Basic damage done by pistol-whip.

function PlayWaiting()
	{
	local float decision;
	local float animspeed;
	animspeed = 0.4 + 0.6 * FRand(); 

	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Sleep';
		
	LoopAnim(NextAnim, animspeed);
	////log("Next brute waiting anim is "$nextanim);
	if (NextAnim == 'Sleep')
		{
		Alertness = -1.0;
		if (decision < 0.1)
			NextAnim = 'StillLook';			
		}
	else if (NextAnim == 'StillLook')
		{
		Alertness = 0.7;
		NextAnim = 'Sleep';
		PlaySound(sound 'growl1');			
 		}
	}

function PlayPatrolStop()
	{
	local float decision;
	local float animspeed;
	animspeed = 0.5 + 0.5 * FRand(); //fixme - add to all creatures

	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Sleep';
		
	LoopAnim(NextAnim, animspeed);
	////log("Next brute waiting anim is "$nextanim);
	if (NextAnim == 'Sleep')
		{
		Alertness = 0.0;
		if (decision < 0.4)
			NextAnim = 'StillLook';
		}
	else if (NextAnim == 'StillLook')
		{
		Alertness = 1.0;
		NextAnim = 'Sleep';
		PlaySound(sound 'growl1');			
 		}
	}

function PlayWaitingGuard()
	{
	PlayWaiting();
	}

function PlayWaitingAmbush()
	{
	Alertness = 1.0;
	LoopAnim('StillLook', 0.3);
	PlaySound(sound 'growl1');	
	}

function PlayFighter()
	{
	LoopAnim('Fighter');
	}

function TweenToFighter(float tweentime)
{
	TweenAnim('Fighter', tweentime);
}

function TweenToRunning(float tweentime)
{
	TweenAnim('Walk', tweentime);
//	PlaySound(Sound 'SeePlayer');	
}

function TweenToWalking(float tweentime)
{
	TweenAnim('Walk', tweentime);
}

function TweenToWaiting(float tweentime)
{
	TweenAnim('Sleep', tweentime);
	PlaySound(Sound 'Sleep');
}

function TweenToPatrolStop(float tweentime)
{
	TweenAnim('Sleep', tweentime);
	PlaySound(Sound 'Sleep');	
}

function PlayRunning()
{
	LoopAnim('Walk', -1.0/GroundSpeed,true,0.3);
}

function PlayWalking()
{
	LoopAnim('Walk', -1.5/GroundSpeed,true,0.3);
}

function PlayThreatening()
{
	if (FRand() < 0.2)
	{
		PlayAnim('PistolWhip');
		PlaySound(sound 'growl4');		
	}
	else
	{
		LoopAnim('StillLook', 0.4 + 0.6 * FRand());
		PlaySound(sound 'growl2');		
	}
}

function PlayTurning()
{
	LoopAnim('StillLook');
	PlaySound(Sound 'Growl4');	
}

function PlayDying()
{
	PlaySound(sound 'Death');
	if (FRand() < 0.5)
		PlayAnim('Die');
	else
		PlayAnim('Die2');
}

function PlayTakeHit(float tweentime, vector HitLoc)
{
	PlayAnim('TakeHit');
	PlaySound(sound 'Hit');
}

function PlayMovingAttack()
{
	bReadyToAttack = true; //so he'll smoothly switch to melee
	PlaySound(Sound 'Growl2');	
	Target = Enemy;
	if ((NextAnim == 'MovingAttack') || (NextAnim == 'None'))
		NextAnim = 'ShootLeft';

	PlayAnim(NextAnim);
	
	if (NextAnim == 'ShootLeft')
		NextAnim = 'ShootRight';
	else if (NextAnim == 'ShootRight')
		{
		if (FRand() < 0.4)
			NextAnim = 'ShootLeft';
		else
			NextAnim = 'WalkLeft';
		}
	else if (NextAnim == 'WalkLeft')
		{
		NextAnim = 'Charging'; 
		bReadyToAttack = false;
		SetTimer(TimeBetweenAttacks  * (1.0 + FRand()),false); //FIXME single spot (function)
		PlayRunning();
		Disable('AnimEnd');
		}
}

//FIXME - put this into the victory dance state?
//Also - need to be able to acquire enemies during victory dance
//(at least if shot)
function PlayVictoryDance()
{
	PlayFighter();
}
	
function SpawnLeftShot()
{
	local Projectile Proj;
	local vector X,Y,Z, projStart;
	GetAxes(Rotation,X,Y,Z);
	
	MakeNoise(1.0);
	////log("Play ranged attack");
	projStart = Location + 1.2 * CollisionRadius * X + 0.5 * CollisionRadius * Y;	
	Proj = spawn(class 'BruteProjectile' ,self,'',projStart);
	if( Proj != None )
		Proj.SetRotation(AdjustAim(proj.speed, projStart, 900, true));  
}

function SpawnRightShot()
{
	local Projectile Proj;
	local vector X,Y,Z, projStart;
	GetAxes(Rotation,X,Y,Z);
	
	MakeNoise(1.0);
	////log("Play ranged attack");
	projStart = Location + 1.2 * CollisionRadius * X - 0.5 * CollisionRadius * Y;
	Proj = spawn(class 'BruteProjectile' ,self,'',projStart);
	if( Proj != None )
		Proj.SetRotation(AdjustAim(proj.speed, projStart, 900, true));  
}

state MeleeAttack
{
ignores SeePlayer, HearNoise, Bump;

function WhipDamageTarget()
{
	DamageTarget(20, (20000.0 * Normal(Target.Location - Location)));
}

function FootStep1()
{
	PlaySound(Sound 'FootStep');
}

function FootStep2()
{
	PlaySound(Sound 'FootStep');
}


function GutShotTarget()
{
	DamageTarget(20, (20000.0 * Normal(Target.Location - Location)));
}

function PlayMeleeAttack()
{
	If (FRand() < 0.3)
 		PlayAnim('GutShot'); 
 	else
  		PlayAnim('PistolWhip');
}

Begin:
	if (Target == None)
		Target = Enemy;

	//log(class$" Melee Attack");
	DesiredRotation = Rotation(Target.Location - Location);
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	Acceleration = vect(0,0,0); //stop
	if (NeedToTurn(Target.Location))
		{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		FinishAnim();
		}
	if (Size(Location - Enemy.Location) > MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('RangedAttack', 'ReadyToAttack'); //FIXME - do for most/all

ReadyToAttack:
	DesiredRotation = Rotation(Target.Location - Location);
	PlayMeleeAttack();
	FinishAnim();
	KeepAttacking();
	Goto('FaceTarget');
}

state RangedAttack
{
ignores SeePlayer, HearNoise, Bump;

Begin:
	if (Target == None)
		Target = Enemy;

	Acceleration = vect(0,0,0); //stop
	//log(class$" Ranged Attack");
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	if (NeedToTurn(Target.Location))
	{
		PlayTurning();
		TurnToward(Target);
	}
	if (Size(Location - Enemy.Location) < MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('MeleeAttack', 'ReadyToAttack'); 

ReadyToAttack:
	TweenAnim('StillFire', 0.3);
	if (NeedToTurn(Target.Location))
	{
		TurnToward(Target);
	}
//	log("start firing");
	FinishAnim();
	DesiredRotation = Rotation(Target.Location - Location);
	SpawnRightShot();
	PlayAnim('StillFire');
	FinishAnim();
	KeepAttacking(0.5);
	Goto('FaceTarget');
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      ShootDamage=0
      WhipDamage=20
      Health=160
      ArmorClass=ARMOR_Super
      bCanPossess=False
      bHasRangedAttack=True
      bMovingRangedAttack=True
      MeleeRange=+00050.000000
      Aggressiveness=+00001.000000
      Intelligence=BRAINS_REPTILE
      GroundSpeed=+00150.000000
      WaterSpeed=+00100.000000
      AirSpeed=+00100.000000
      AccelRate=+00120.000000
      JumpZ=-00001.000000
      CombatStyle=+00000.900000
      DrawType=DT_Mesh
      Mesh=BigMan
      CollisionRadius=+00048.000000
      CollisionHeight=+00046.000000
      Mass=+00400.000000
      RotationSpeed=45000
   End DefaultProperties
End Class

Begin Class Name=ArchAngel
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// ArchAngel.
//=============================================================================
class ArchAngel expands Brute
	package(UnGame);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      ShootDamage=81
      WhipDamage=85
      Health=100
      ArmorClass=ARMOR_Normal
      bHasRangedAttack=False
      bMovingRangedAttack=False
      TimeBetweenAttacks=+00000.000000
      MeleeRange=+00000.000000
      Aggressiveness=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00004.300000
      WaterSpeed=+00000.000000
      AirSpeed=+00000.000000
      AccelRate=+00001.000000
      CombatStyle=+00000.000000
      DrawScale=+00001.150000
      CollisionRadius=+00046.000000
      CollisionHeight=+00057.000000
      bPitch=False
      bYaw=False
      bRoll=False
      RotationSpeed=0
   End DefaultProperties
End Class

Begin Class Name=Gasbag
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Gasbag.
//=============================================================================
class Gasbag expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=GasBag ANIVFILE=..\MODELS\ANIV28.3D DATAFILE=..\MODELS\DATA28.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=GasBag X=0 Y=150 Z=0 YAW=64

#exec MESH SEQUENCE MESH=GasBag SEQ=All      STARTFRAME=0  NUMFRAMES=226
#exec MESH SEQUENCE MESH=GasBag SEQ=2Punch   STARTFRAME=0  NUMFRAMES=24
#exec MESH SEQUENCE MESH=GasBag SEQ=Belch    STARTFRAME=24 NUMFRAMES=29
#exec MESH SEQUENCE MESH=GasBag SEQ=Deflate  STARTFRAME=53 NUMFRAMES=31
#exec MESH SEQUENCE MESH=GasBag SEQ=Fiddle   STARTFRAME=84 NUMFRAMES=30
#exec MESH SEQUENCE MESH=GasBag SEQ=Fighter  STARTFRAME=114 NUMFRAMES=1
#exec MESH SEQUENCE MESH=GasBag SEQ=Float    STARTFRAME=115 NUMFRAMES=25
#exec MESH SEQUENCE MESH=GasBag SEQ=Grab     STARTFRAME=140 NUMFRAMES=40
#exec MESH SEQUENCE MESH=GasBag SEQ=Pound    STARTFRAME=180 NUMFRAMES=24
#exec MESH SEQUENCE MESH=GasBag SEQ=T1       STARTFRAME=204 NUMFRAMES=5
#exec MESH SEQUENCE MESH=GasBag SEQ=T2       STARTFRAME=209 NUMFRAMES=9
#exec MESH SEQUENCE MESH=GasBag SEQ=T3       STARTFRAME=218 NUMFRAMES=4
#exec MESH SEQUENCE MESH=GasBag SEQ=T4       STARTFRAME=222 NUMFRAMES=4

#exec TEXTURE IMPORT NAME=GasBag2 FILE=..\MODELS\gasbod.PCX FAMILY="Skins" 
#exec TEXTURE IMPORT NAME=GasBag1 FILE=..\MODELS\gasarm.PCX FAMILY="Skins" PALETTE=GasBag1 

#exec MESHMAP NEW   MESHMAP=GasBag MESH=GasBag 
#exec MESHMAP SCALE MESHMAP=GasBag X=0.05 Y=0.05 Z=0.1

#exec MESHMAP SETTEXTURE MESHMAP=GasBag NUM=5 TEXTURE=GasBag1 
#exec MESHMAP SETTEXTURE MESHMAP=GasBag NUM=6 TEXTURE=GasBag2

//-----------------------------------------------------------------------------
// Gasbag variables.

// Sounds.
var() sound
	BelchSound,		// Sound made when monster belches.
	PunchSound,     // Sound made during each punch.
	PoundSound;     // Sound made during pound .

// Attack damage.
var() byte
	BelchDamage,	// Basic damage done by belch.
	PunchDamage,	// Basic damage done by each punch.
	PoundDamage;	// Basic damage done by pound.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      BelchSound=None
      PunchSound=None
      PoundSound=None
      BelchDamage=10
      PunchDamage=20
      PoundDamage=25
      bCanPossess=False
      TimeBetweenAttacks=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00003.000000
      WaterSpeed=+00000.000000
      AccelRate=+00001.000000
      JumpZ=+00000.000000
      DrawType=DT_Mesh
      Mesh=Gasbag
      CollisionRadius=+00028.000000
      CollisionHeight=+00010.000000
      bPitch=False
      bYaw=False
      bRoll=False
      Mass=+00070.000000
   End DefaultProperties
End Class

Begin Class Name=Manta
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Manta.
//=============================================================================
class Manta expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Manta ANIVFILE=..\MODELS\aniv29.3D DATAFILE=..\MODELS\data29.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Manta X=0 Y=-100 Z=100 YAW=64
#exec MESH SEQUENCE MESH=Manta SEQ=All  STARTFRAME=0  NUMFRAMES=152
#exec MESH SEQUENCE MESH=Manta SEQ=Fly  STARTFRAME=0  NUMFRAMES=20
#exec MESH SEQUENCE MESH=Manta SEQ=Sting  STARTFRAME=20  NUMFRAMES=30
#exec MESH SEQUENCE MESH=Manta SEQ=Whip  STARTFRAME=50  NUMFRAMES=30
#exec MESH SEQUENCE MESH=Manta SEQ=Death  STARTFRAME=81  NUMFRAMES=25
#exec MESH SEQUENCE MESH=Manta SEQ=Landing  STARTFRAME=106  NUMFRAMES=25
#exec MESH SEQUENCE MESH=Manta SEQ=TakeOff  STARTFRAME=132  NUMFRAMES=20
#exec TEXTURE IMPORT NAME=JManta1 FILE=..\MODELS\manta.PCX FAMILY="Skins" PALETTE=JManta1 FLAGS=2

#exec MESHMAP NEW   MESHMAP=Manta MESH=Manta 
#exec MESHMAP SCALE MESHMAP=Manta X=0.05 Y=0.05 Z=0.1

#exec MESHMAP SETTEXTURE MESHMAP=Manta NUM=2 TEXTURE=JManta1

//-----------------------------------------------------------------------------
// Manta variables.

// Sounds.
var() sound
	StingSound,		// Sound made when monster stings.
	WhipSound;		// Sound made during whip.

// Attack damage.
var() byte
	StingDamage,	// Basic damage done by Sting.
	WhipDamage;		// Basic damage done by whip.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      StingSound=None
      WhipSound=None
      StingDamage=20
      WhipDamage=20
      bCanPossess=False
      TimeBetweenAttacks=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00009.500000
      WaterSpeed=+00000.000000
      AccelRate=+00001.000000
      JumpZ=+00000.000000
      DrawType=DT_Mesh
      Mesh=Manta
      CollisionRadius=+00025.000000
      CollisionHeight=+00010.000000
      bPitch=False
      bYaw=False
      bRoll=False
      Mass=+00080.000000
   End DefaultProperties
End Class

Begin Class Name=Tentacle
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Tentacle.
//=============================================================================
class Tentacle expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Tentacle ANIVFILE=..\MODELS\aniv42.3D DATAFILE=..\MODELS\data42.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Tentacle X=0 Y=-180 Z=100 YAW=64
#exec MESH SEQUENCE MESH=Tentacle SEQ=All  STARTFRAME=0  NUMFRAMES=196
#exec MESH SEQUENCE MESH=Tentacle SEQ=Waver  STARTFRAME=0  NUMFRAMES=30
#exec MESH SEQUENCE MESH=Tentacle SEQ=Shoot  STARTFRAME=30 NUMFRAMES=30
#exec MESH SEQUENCE MESH=Tentacle SEQ=Mebax  STARTFRAME=60 NUMFRAMES=10
#exec MESH SEQUENCE MESH=Tentacle SEQ=Death  STARTFRAME=100 NUMFRAMES=70
#exec MESH SEQUENCE MESH=Tentacle SEQ=T1     STARTFRAME=171 NUMFRAMES=10
#exec MESH SEQUENCE MESH=Tentacle SEQ=T2     STARTFRAME=181 NUMFRAMES=15
#exec TEXTURE IMPORT NAME=JTentacle1 FILE=..\MODELS\Tentacle.PCX FAMILY="Skins" PALETTE=JTentacle1 

#exec MESHMAP NEW   MESHMAP=Tentacle MESH=Tentacle 
#exec MESHMAP SCALE MESHMAP=Tentacle X=0.1 Y=0.1 Z=0.2

#exec MESHMAP SETTEXTURE MESHMAP=Tentacle NUM=1 TEXTURE=JTentacle1

//-----------------------------------------------------------------------------
// Tentacle variables.

// Sounds.
var() sound
	ShootSound,		// Sound made when monster shoots.
	MebaxSound;		// Sound made during mebax.

// Attack damage.
var() byte WhipDamange; // Damage done by whipping.

// Projectile.
var() projectile Projectile; // The projectile used.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      ShootSound=None
      MebaxSound=None
      WhipDamange=0
      Projectile=None
      bCanPossess=False
      PeripheralVision=-00001.000000
      TimeBetweenAttacks=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00000.000000
      WaterSpeed=+00000.000000
      AccelRate=+00001.000000
      JumpZ=+00000.000000
      DrawType=DT_Mesh
      Mesh=Tentacle
      CollisionRadius=+00036.000000
      CollisionHeight=+00059.000000
      bPitch=False
      bYaw=False
      bRoll=False
   End DefaultProperties
End Class

Begin Class Name=Scout
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Scout used for path generation.
//=============================================================================
class Scout expands ScriptedPawn
	package(UnGame);

function PreBeginPlay()
{
	Destroy(); //scouts shouldn't exist during play
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      bCanPossess=False
      TimeBetweenAttacks=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00000.000000
      WaterSpeed=+00000.000000
      AccelRate=+00001.000000
      JumpZ=+00000.000000
      CombatStyle=+4363467783093056800000000.000000
      DrawType=DT_None
      CollisionRadius=+00052.000000
      CollisionHeight=+00032.000000
      bPitch=False
      bYaw=False
      bRoll=False
   End DefaultProperties
End Class

Begin Class Name=View
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// A view, used in UnrealEd.
//=============================================================================
class View expands ScriptedPawn
	package(UnEngine);

#exec Texture Import File=..\Graphics\S_Camera.pcx Name=S_Camera Palette=Palette Mips=Off Flags=2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      bFixedStart=False
      TimeBetweenAttacks=+00000.000000
      AttitudeToPlayer=ATTITUDE_Fear
      Intelligence=BRAINS_NONE
      GroundSpeed=+00000.000000
      WaterSpeed=+00000.000000
      AccelRate=+00001.000000
      JumpZ=+00000.000000
      bCollideActors=False
      bCollideWorld=False
      Location=(-00500.000000,-00300.000000,+00300.000000)
      Texture=S_Camera
      CollisionHeight=+00055.000000
      LightBrightness=100
      LightRadius=16
      bPitch=False
      bYaw=False
      bRoll=False
   End DefaultProperties
End Class

Begin Class Name=RazorFish
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// RazorFish.
//=============================================================================
class RazorFish expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=fish ANIVFILE=..\MODELS\fish_a.3D DATAFILE=..\MODELS\fish_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=fish X=0 Y=-60 Z=0 YAW=64 ROLL=0 

#exec MESH SEQUENCE MESH=fish SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=fish SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=Jfish1 FILE=..\MODELS\fish.PCX FAMILY=Skins PALETTE=Jfish1 

#exec MESHMAP NEW   MESHMAP=fish MESH=fish 
#exec MESHMAP SCALE MESHMAP=fish X=0.05 Y=0.05 Z=0.1

#exec MESHMAP SETTEXTURE MESHMAP=fish NUM=1 TEXTURE=Jfish1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
   End DefaultProperties
End Class

Begin Class Name=Krall
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Krall.
//=============================================================================
class Krall expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Krall ANIVFILE=..\MODELS\kralla.3D DATAFILE=..\MODELS\kralld.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Krall X=70 Y=350 Z=-120 YAW=64

#exec MESH SEQUENCE MESH=krall SEQ=All          STARTFRAME=0   NUMFRAMES=452
#exec MESH SEQUENCE MESH=krall SEQ=Breath       STARTFRAME=0   NUMFRAMES=29
#exec MESH SEQUENCE MESH=krall SEQ=Die1         STARTFRAME=29  NUMFRAMES=45
#exec MESH SEQUENCE MESH=krall SEQ=Fighter      STARTFRAME=74  NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=Hit          STARTFRAME=75  NUMFRAMES=14
#exec MESH SEQUENCE MESH=krall SEQ=Look         STARTFRAME=89  NUMFRAMES=44
#exec MESH SEQUENCE MESH=krall SEQ=Shoot1       STARTFRAME=133 NUMFRAMES=24
#exec MESH SEQUENCE MESH=krall SEQ=Shoot2       STARTFRAME=157 NUMFRAMES=44
#exec MESH SEQUENCE MESH=krall SEQ=Stand        STARTFRAME=201 NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=Strike1      STARTFRAME=202 NUMFRAMES=20
#exec MESH SEQUENCE MESH=krall SEQ=Strike2      STARTFRAME=222 NUMFRAMES=23
#exec MESH SEQUENCE MESH=krall SEQ=Strike3      STARTFRAME=245 NUMFRAMES=29
#exec MESH SEQUENCE MESH=krall SEQ=T1           STARTFRAME=274 NUMFRAMES=4
#exec MESH SEQUENCE MESH=krall SEQ=T2           STARTFRAME=278 NUMFRAMES=9
#exec MESH SEQUENCE MESH=krall SEQ=T3           STARTFRAME=287 NUMFRAMES=14
#exec MESH SEQUENCE MESH=krall SEQ=T4           STARTFRAME=301 NUMFRAMES=9
#exec MESH SEQUENCE MESH=krall SEQ=Throw        STARTFRAME=310 NUMFRAMES=49
#exec MESH SEQUENCE MESH=krall SEQ=Twirl        STARTFRAME=359 NUMFRAMES=34
#exec MESH SEQUENCE MESH=krall SEQ=Walk         STARTFRAME=393 NUMFRAMES=29
#exec MESH SEQUENCE MESH=krall SEQ=Footup       STARTFRAME=422 NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=Run          STARTFRAME=428 NUMFRAMES=20
#exec MESH SEQUENCE MESH=krall SEQ=GutHit     STARTFRAME=448 NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=HeadHit      STARTFRAME=449 NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=LeftHit      STARTFRAME=450 NUMFRAMES=1
#exec MESH SEQUENCE MESH=krall SEQ=RightHit     STARTFRAME=451 NUMFRAMES=1

#exec TEXTURE IMPORT NAME=krall FILE=..\MODELS\krall.PCX FAMILY=Skins 

#exec MESHMAP NEW   MESHMAP=krall MESH=krall 
#exec MESHMAP SCALE MESHMAP=krall X=0.1 Y=0.1 Z=0.2

#exec MESHMAP SETTEXTURE MESHMAP=krall NUM=1 TEXTURE=krall

#exec MESH NOTIFY MESH=krall SEQ=Shoot1 TIME=0.4 FUNCTION=SpawnShot
#exec MESH NOTIFY MESH=krall SEQ=Shoot2 TIME=0.53 FUNCTION=SpawnShot
#exec MESH NOTIFY MESH=krall SEQ=Shoot2 TIME=0.8 FUNCTION=ShotMove
#exec MESH NOTIFY MESH=krall SEQ=Strike1 TIME=0.375 FUNCTION=StrikeDamageTarget
#exec MESH NOTIFY MESH=krall SEQ=Strike2 TIME=0.5 FUNCTION=StrikeDamageTarget
#exec MESH NOTIFY MESH=krall SEQ=Strike3 TIME=0.26 FUNCTION=PoundDamageTarget
#exec MESH NOTIFY MESH=krall SEQ=Throw TIME=0.19 FUNCTION=ThrowDamageTarget
#exec MESH NOTIFY MESH=krall SEQ=Throw TIME=0.42 FUNCTION=ThrowTarget

#exec AUDIO IMPORT FILE="..\Sounds\Krall\death2.UFX" NAME="Death1" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\deathcry.UFX" NAME="Death2" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\injur1.UFX" NAME="Injury1" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\speech3.UFX" NAME="Speech3" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\staff1.UFX" NAME="Staff1" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\yell2.UFX" NAME="Yell2" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\swoosh3.UFX" NAME="swoosh3" FAMILY="Krall"
#exec AUDIO IMPORT FILE="..\Sounds\Krall\swoosh5.UFX" NAME="swoosh5" FAMILY="Krall"


var bool AttackSuccess;

function PlayWaiting()
	{
	local float decision;
	local float animspeed;
	animspeed = 0.4 + 0.6 * FRand(); 
	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Breath';
		
	LoopAnim(NextAnim, animspeed);
	////log("Next krall waiting anim is "$nextanim);
	if (NextAnim == 'Breath')
		{
		Alertness = 0.0;
		if (decision < 0.2)
			NextAnim = 'Look';
		}
	else if (NextAnim == 'Look')
		{
		Alertness = 1.0;
		if (decision < 0.3) 
			NextAnim = 'Twirl';
		else 
			NextAnim = 'Breath';
 		}
 	else if (NextAnim == 'Twirl')
 		{
 		Alertness = 0.0;
 		if (decision < 0.5) 
			NextAnim = 'Twirl';
		else 
			NextAnim = 'Breath';
 		}
		
	}

function PlayPatrolStop()
	{
	local float decision;
	local float animspeed;
	animspeed = 0.5 + 0.5 * FRand(); //fixme - add to all creatures
	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Breath';
		
	LoopAnim(NextAnim, animspeed);
	////log("Next krall patrolstop anim is "$nextanim);
	if (NextAnim == 'Breath')
		{
		Alertness = 0.0;
		if (decision < 0.4)
			NextAnim = 'Look';
		}
	else if (NextAnim == 'Look')
		{
		Alertness = 1.0;
		if (decision < 0.3) 
			NextAnim = 'Twirl';
		else 
			NextAnim = 'Breath';
 		}
 	else if (NextAnim == 'Twirl')
 		{
 		Alertness = 0.0;
 		if (decision < 0.5) 
			NextAnim = 'Twirl';
		else 
			NextAnim = 'Breath';
 		}
		
	}
	
	
function PlayWaitingGuard()
	{
	PlayWaiting();
	}

function PlayWaitingAmbush()
	{
	if (FRand() < 0.4)
		LoopAnim('Look', 0.3);
	else 
		LoopAnim('Breath');
	Alertness = 1.0;
	}

function PlayFighter()
	{
	LoopAnim('Fighter');
	}

function TweenToFighter(float tweentime)
{
	TweenAnim('Fighter', tweentime);
}

function TweenToRunning(float tweentime)
{
	TweenAnim('Run', tweentime);
}

function TweenToWalking(float tweentime)
{
	TweenAnim('Walk', tweentime);
}

function TweenToWaiting(float tweentime)
{
	TweenAnim('Stand', tweentime);
}

function TweenToPatrolStop(float tweentime)
{
	TweenAnim('Stand', tweentime);
}

function PlayMovingAttack()
{
	bReadyToAttack = true; //so he'll smoothly switch to melee
	Target = Enemy;
	PlayAnim('Shoot2');
	if (FRand() < 0.3)
		{
		NextAnim = 'Charging'; //FIXME - generalize
		bReadyToAttack = false;
		SetTimer(TimeBetweenAttacks  * (1.0 + FRand()),false); //FIXME single spot (function)
		}

}

function PlayRunning()
{
	LoopAnim('Run', -1.0/GroundSpeed,true,0.3);
}

function PlayWalking()
{
	LoopAnim('Walk', -2.0/GroundSpeed,true,0.3);
}

function PlayThreatening()
{
	local float decision;
	local float animspeed;
	decision = FRand();
	
    if (FRand() < 0.3) PlaySound(Sound 'Yell2');		
	animspeed = 0.4 + 0.6 * FRand(); 
	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Breath';
	
	if (NextAnim == 'TweenToBreath')
		TweenAnim('Breath', 0.3);
	else	
		LoopAnim(NextAnim, animspeed);
	////log("Next krall threatening anim is "$nextanim);

	if (NextAnim == 'Breath')
		{
		if (decision < 0.2)
			NextAnim = 'T3';
		else if (decision < 0.3)
			NextAnim = 'Twirl';
		}
	else if (NextAnim == 'Twirl')
		{
		if (decision < 0.9)
			NextAnim = 'Breath';
		}
	else if (NextAnim == 'T3')
		{
		if (decision < 0.5)
		{
			NextAnim = 'Strike1';
			PlaySound(Sound 'Swoosh5');
		}
		else 
		{
			NextAnim = 'Strike2';
			PlaySound(Sound 'Swoosh3');
		}
		}
	else if (NextAnim == 'TweenToBreath')
		NextAnim = 'Breath';
	else
		{
		if (decision < 0.5)
			NextAnim = 'Strike1';
		else 
			NextAnim = 'Strike2';
		decision = FRand();
		if (decision < 0.75)
			NextAnim = 'TweenToBreath'; 
		}
}

function PlayTurning()
{
	TweenToFighter(0.3);
}

function PlayDying()
{
	PlayAnim('Die1');
	if (FRand() < 0.5) PlaySound(Sound 'Death1');	
	else PlaySound(Sound 'Death1');	    
}

function PlayTakeHit(float tweentime, vector HitLoc)
{
	local vector X,Y,Z, HitVec;
	local float dotp;
    PlaySound(Sound 'Injury1');		
	GetAxes(Rotation,X,Y,Z);
	HitVec = Normal(HitLoc - Location);
	//FIXME - move this function to damage?
	//log ("Play Take Hit");
	dotp = HitVec dot X;
	//log ("yaw test = "$dotp);
	if (dotp > 0.8) //then hit in front
		{
		dotp = HitVec dot Z;
		//log ("pitch test = "$dotp);
		if (dotp > 0.4)
			TweenAnim('HeadHit', tweentime);
		else
			TweenAnim('GutHit', tweentime);
		}
	else if (dotp < -0.8) // then hit in back
		{
		dotp = HitVec dot Z;
		//log ("pitch test = "$dotp);
		if (dotp > 0.4)
			TweenAnim('GutHit', tweentime);
		else
			TweenAnim('HeadHit', tweentime);
		}
	else
		{
		dotp = HitVec dot Y;
		//log ("left/right test = "$dotp);
		if (dotp > 0.0)
			TweenAnim('LeftHit', tweentime);
		else
			TweenAnim('RightHit', tweentime);
		}
}

//FIXME - put this into the victory dance state?
//Also - need to be able to acquire enemies during victory dance
//(at least if shot)
function PlayVictoryDance()
{
    PlaySound(Sound 'Speech3');	
	PlayAnim('Twirl', 0.5);
}
	
function SpawnShot()
{
	local Projectile Proj;
	local vector X,Y,Z, projStart;
	GetAxes(Rotation,X,Y,Z);
	
	MakeNoise(1.0);
	DesiredSpeed = 0.0; //For Kraal shoot2 (walking shoot, w/ pause)
	////log("Play ranged attack");
	projStart = Location + 1.2 * CollisionRadius * X - 0.5 * CollisionRadius * Y;
    PlaySound(Sound 'Staff1');		
	Proj = spawn(class 'KraalBolt' ,self,'',projStart);
	if( Proj != None )
		Proj.SetRotation(AdjustAim(proj.speed, projStart, 500, true));  
}

function ShotMove()
{
	DesiredSpeed = 1.0;
}

//also change accuracy based on enemy normal velocity, and own accuracy
state MeleeAttack
{
ignores SeePlayer, HearNoise, Bump;

function StrikeDamageTarget()
{
	DamageTarget(20, 10000.0 * Normal(Target.Location - Location));
}

function PoundDamageTarget()
{
	DamageTarget(20, 7000.0 * Normal(Target.Location - Location));
}

function ThrowDamageTarget()
{
	AttackSuccess = DamageTarget(30, vect(0,0,0));
	if (AttackSuccess && (Target.Physics == PHYS_Walking))
		Target.Physics = PHYS_None; //caught on spear
}

function ThrowTarget() //FIXME - do in two parts
{
	local rotation newRot;
	if (AttackSuccess)
		{
		newRot = Target.Rotation;
		newRot.Pitch = 4096;
		Target.SetRotation(newRot);
		if (Target.Physics == PHYS_None)
			Target.Physics = PHYS_Falling;
		Target.Velocity += (20000.0 * (Normal(Target.Location - Location) + vect(0,0,1)))/Target.Mass;
		}
}
	
function PlayMeleeAttack()
{
	local float decision;

	decision = FRand();
	if (decision < 0.25)
		PlayAnim('Strike1'); 
 	else if (decision < 0.5)
   		PlayAnim('Strike2');
 	else if (decision < 0.75)
 		PlayAnim('Strike3');
 	else
 		PlayAnim('Throw'); 
}

Begin:
	if (Target == None)
		Target = Enemy;

	//log(class$" Melee Attack");
	DesiredRotation = Rotation(Target.Location - Location);
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	Acceleration = vect(0,0,0); //stop
	if (NeedToTurn(Target.Location))
		{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		FinishAnim();
		}

	if (Size(Location - Enemy.Location) > MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('RangedAttack', 'ReadyToAttack'); //FIXME - do for most/all

ReadyToAttack:
	DesiredRotation = Rotation(Target.Location - Location);
	PlayMeleeAttack();
	FinishAnim();
	KeepAttacking();
	Goto('FaceTarget');
}

state RangedAttack
{
ignores SeePlayer, HearNoise, Bump;

Begin:
	if (Target == None)
		Target = Enemy;

	Acceleration = vect(0,0,0); //stop
	//log(class$" Ranged Attack");
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	if (NeedToTurn(Target.Location))
	{
		PlayTurning();
		TurnToward(Target);
	}
	if (Size(Location - Enemy.Location) < MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('MeleeAttack', 'ReadyToAttack'); 

ReadyToAttack:
	DesiredRotation = Rotation(Target.Location - Location);
	PlayAnim('Shoot1');
	FinishAnim();
	KeepAttacking(0.5);
	Goto('FaceTarget');
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      AttackSuccess=False
      bHasRangedAttack=True
      bMovingRangedAttack=True
      HearingThreshold=+00000.200000
      MeleeRange=+00050.000000
      Aggressiveness=+00000.300000
      Visibility=128
      AttitudeToPlayer=ATTITUDE_Threaten
      Intelligence=BRAINS_HUMAN
      GroundSpeed=+00240.000000
      WaterSpeed=+00100.000000
      AirSpeed=+00100.000000
      AccelRate=+00500.000000
      JumpZ=+00300.000000
      CombatStyle=+00000.200000
      DrawType=DT_Mesh
      Mesh=Krall
      CollisionHeight=+00046.000000
      bMeshCurvy=False
      Mass=+00150.000000
      RotationSpeed=50000
   End DefaultProperties
End Class

Begin Class Name=Titan
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Titan.
//=============================================================================
class Titan expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Titan ANIVFILE=..\MODELS\titana.3D DATAFILE=..\MODELS\titand.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Titan X=40 Y=300 Z=-65 YAW=64

#exec MESH SEQUENCE MESH=titan SEQ=All       STARTFRAME=0   NUMFRAMES=305
#exec MESH SEQUENCE MESH=titan SEQ=TWalk001  STARTFRAME=0   NUMFRAMES=60
#exec MESH SEQUENCE MESH=titan SEQ=FootUp    STARTFRAME=6   NUMFRAMES=1
#exec MESH SEQUENCE MESH=titan SEQ=TBrea001  STARTFRAME=60  NUMFRAMES=30
#exec MESH SEQUENCE MESH=titan SEQ=TDeat001  STARTFRAME=90  NUMFRAMES=58
#exec MESH SEQUENCE MESH=titan SEQ=TFigh001  STARTFRAME=148 NUMFRAMES=1
#exec MESH SEQUENCE MESH=titan SEQ=TPunc001  STARTFRAME=149 NUMFRAMES=24
#exec MESH SEQUENCE MESH=titan SEQ=TSlap001  STARTFRAME=173 NUMFRAMES=29
#exec MESH SEQUENCE MESH=titan SEQ=TSnif001  STARTFRAME=202 NUMFRAMES=35
#exec MESH SEQUENCE MESH=titan SEQ=TStom001  STARTFRAME=237 NUMFRAMES=34
#exec MESH SEQUENCE MESH=titan SEQ=TThro001  STARTFRAME=271 NUMFRAMES=34

#exec TEXTURE IMPORT NAME=Jtitan1 FILE=..\MODELS\titan.PCX FAMILY=Skins PALETTE=Jtitan1 

#exec MESHMAP NEW   MESHMAP=titan MESH=titan 
#exec MESHMAP SCALE MESHMAP=titan X=0.25 Y=0.25 Z=0.5

#exec MESHMAP SETTEXTURE MESHMAP=titan NUM=1 TEXTURE=Jtitan1

#exec MESH NOTIFY MESH=titan SEQ=TWalk001 TIME=0.39 FUNCTION=FootStep
#exec MESH NOTIFY MESH=titan SEQ=TWalk001 TIME=0.89 FUNCTION=FootStep
#exec MESH NOTIFY MESH=titan SEQ=TWalk001 TIME=0.55 FUNCTION=StartMoving
#exec MESH NOTIFY MESH=titan SEQ=TWalk001 TIME=0.97 FUNCTION=StartMoving
#exec MESH NOTIFY MESH=titan SEQ=TStom001 TIME=0.4 FUNCTION=Stomp
#exec MESH NOTIFY MESH=titan SEQ=TSlap001 TIME=0.46 FUNCTION=SlapDamageTarget
#exec MESH NOTIFY MESH=titan SEQ=TPunc001 TIME=0.61 FUNCTION=PunchDamageTarget
#exec MESH NOTIFY MESH=titan SEQ=TThro001 TIME=0.68 FUNCTION=SpawnRock
#exec MESH NOTIFY MESH=titan SEQ=TThro001 TIME=0.75 FUNCTION=SpawnRock2

#exec AUDIO IMPORT FILE="..\Sounds\Titan\FootStep.UFX" NAME="FootStep" FAMILY="Titan"
#exec AUDIO IMPORT FILE="..\Sounds\Titan\Stomp2.UFX" NAME="Stomp2" FAMILY="Titan"
#exec AUDIO IMPORT FILE="..\Sounds\Titan\Swing1.UFX" NAME="Swing1" FAMILY="Titan"
#exec AUDIO IMPORT FILE="..\Sounds\Titan\Titan2.UFX" NAME="Titan2" FAMILY="Titan"
#exec AUDIO IMPORT FILE="..\Sounds\Titan\Titan3.UFX" NAME="Titan3" FAMILY="Titan"
#exec AUDIO IMPORT FILE="..\Sounds\Titan\TitanFall.UFX" NAME="TitanFall" FAMILY="Titan"

//TITAN variables;
var bool bStomp;
var float realSpeed;

function Callback(object Other)
	{
	local float dist;
	local Pawn Otherpawn;

	Otherpawn = Pawn(Other);

	if (Otherpawn.Physics != PHYS_Walking)
		return;
	
	if (Otherpawn == self)
		return;
				
	if (!Otherpawn.bIsPlayer)
		{	
		if (!bStomp) //its a footstep
			return;
		else
			{
			dist = Size(Location - Otherpawn.Location);
			if (dist > 500)
				return;
			}
		}
	else
		{
		Otherpawn.count = 0.15; //shake player view
		dist = Size(Location - Otherpawn.Location);
		if (dist > 2000)
			return;
		}
	
	dist = 0.5 * dist + 500;
	OtherPawn.Velocity = 0.5 * OtherPawn.Velocity + 100 * VRand();
	Otherpawn.Velocity.Z =  7000000.0/(dist * Otherpawn.Mass);
	Otherpawn.Physics = PHYS_Falling;
	if (bStomp)
		Otherpawn.Velocity.Z = Otherpawn.Velocity.Z * 5.0;		
	}

function FootStep()
{
	//slightly throw player if nearby ,& play footstep sound
	bStomp = false;
	Broadcast('',class 'Pawn').Callme(Self);
	realSpeed = DesiredSpeed; //fixme - don't stop if very low friction
	DesiredSpeed = 0.0;
	PlaySound(Sound 'FootStep');
}

function StartMoving()
{
	DesiredSpeed = realSpeed;
}

function Stomp()
{
	//throw all nearby creatures, and play sound
	bStomp = true;
	Broadcast('',class 'Pawn').Callme(Self);
	PlaySound(Sound 'Stomp2');
	if (Frand() < 0.4) PlaySound(Sound 'Titan2');
}

function PlayWaiting()
	{
	local float decision;
	local float animspeed;
	
	decision = FRand();
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'TBrea001';

	animspeed = 0.2 + 0.5 * FRand();
	LoopAnim(NextAnim, animspeed);
	Alertness = 0.0;
	
	if (NextAnim == 'TBrea001')
		{
		if (decision < 0.1)
			NextAnim = 'TSnif001';			
		}
	else
		NextAnim = 'TBrea001';
	}
	
//PlayPatrolStop(), PlayWaitingGuard(), and PlayWaitingAmbush() all use PlayWaiting(); 			
function PlayPatrolStop()
{
	DesiredSpeed = 0.0;
	PlayWaiting();
}

function PlayWaitingGuard()
{
	PlayWaiting();
}

function PlayWaitingAmbush()
{
	DesiredSpeed = 0.0;
	PlayWaiting();
	//Alertness = 0.5; //is Titan ever very alert?
}

function PlayFighter()
{
	DesiredSpeed = 0.0;
	LoopAnim('TFigh001');
}

function TweenToFighter(float tweentime)
{
	TweenAnim('TFigh001', tweentime);
}

function TweenToRunning(float tweentime)
{
	TweenAnim('TWalk001', tweentime);
}

function TweenToWalking(float tweentime)
{
	TweenAnim('TWalk001', tweentime);
}

function TweenToWaiting(float tweentime)
{
	TweenAnim('TBrea001', tweentime);
}

function TweenToPatrolStop(float tweentime)
{
	TweenAnim('TBrea001', tweentime);
}

function PlayRunning()
{
	LoopAnim('TWalk001', -1.0/GroundSpeed,true, 0.8);
}

function PlayWalking()
{
	LoopAnim('TWalk001', -1.0/GroundSpeed,true, 0.8);
	PlaySound(Sound 'Titan2');		
}

function PlayThreatening()
{
	local float decision;
	decision = FRand();
	DesiredSpeed = 0.0;
	
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Breath';
	
	if (NextAnim == 'Breath')
		{
		LoopAnim('TBrea001', 0.4 + 0.6 * FRand());
		PlaySound(Sound 'Titan2');			
		if (FRand() < 0.2)
			NextAnim = 'TweenToThreat';
		}
	else if (NextAnim == 'TweenToThreat')
		{
		TweenAnim('TFigh001', 0.2);
		NextAnim = 'Threaten';
		PlaySound(Sound 'Titan3');			
		}
	else if (NextAnim == 'Threaten')
		{
		PlayAnim('TStom001');
		NextAnim = 'TweenToBreath';
		}
	else if (NextAnim == 'TweenToBreath')
		{
		TweenAnim('TBrea001', 0.2);
		NextAnim = 'Breath';
		PlaySound(Sound 'Titan2');			
		}
}

function PlayTurning()
{
	DesiredSpeed = 0.0;
	TweenAnim('FootUp', 0.7);
}

function PlayDying()
{
	DesiredSpeed = 0.0;
	PlayAnim('TDeat001');
	PlaySound(Sound 'TitanFall');	
}

function PlayTakeHit(float tweentime, vector HitLoc)
{
	TweenAnim('TFigh001', tweentime);
	PlaySound(Sound 'Titan3');	
}

function PlayBigHit()
{
	local vector HitLoc;
	HitLoc = Location;
	if (FRand() > 0.5)
	HitLoc.Z += EyeHeight;
	PlayTakeHit(0.3, HitLoc);
	PlaySound(Sound 'Titan3');		
}

final function SpawnRock()
{
	local Projectile Proj;
	local vector X,Y,Z, projStart;
	GetAxes(Rotation,X,Y,Z);
	
	MakeNoise(1.0);
	projStart = Location + 1.2 * CollisionRadius * X - CollisionRadius * Y;
	Proj = spawn(class 'Rock1' ,self,'',projStart);
	if( Proj != None )
		Proj.SetRotation(AdjustAim(proj.speed, projStart, 200, true)); 
}

final function SpawnRock2()
{
	local Projectile Proj;
	local vector X,Y,Z, projStart;
	if (FRand() < 0.5)
		return;
	GetAxes(Rotation,X,Y,Z);
	
	MakeNoise(1.0);
	projStart = Location + 1.2 * CollisionRadius * X -  0.5 * CollisionRadius * Y;
	Proj = spawn(class 'Rock3' ,self,'',projStart);
	if( Proj != None )
		Proj.SetRotation(AdjustAim(proj.speed, projStart, 1500, true)); 
}

function PlayVictoryDance()
{
	DesiredSpeed = 0.0;
	PlayAnim('TStom001', 0.6); //gib the enemy here!
	PlaySound(Sound 'Stomp2');		
}

state MeleeAttack
{
ignores SeePlayer, HearNoise, Bump;
		
final function PunchDamageTarget()
{
	DamageTarget(70, (50000.0 * (Normal(Target.Location - Location))));
}

final function SlapDamageTarget()
{
	local vector X,Y,Z;
	GetAxes(Rotation,X,Y,Z);
	
	DamageTarget(80, (50000.0 * ( Y + vect(0,0,1))));
}

//Titan doesn't need to face as directly
function bool NeedToTurn(vector targ)
{
	local rotation desiredRot;
	local bool need;
	need = true;
	desiredRot = Rotation(targ - location);
	desiredRot.Yaw = desiredRot.Yaw & 65535;
	if (Abs(desiredRot.Yaw - (Rotation.Yaw & 65535)) < 8000)
		need = false;
	else if (Abs(desiredRot.Yaw - (Rotation.Yaw & 65535)) > 57535)
		need = false;

	return need;
}
	
final function PlayMeleeAttack()
{
	local int hitdamage;
	local float decision;
	decision = FRand();
	////log("Start Melee Attack");
	if (decision < 0.4)
 		PlayAnim('TPunc001');
	else if (decision < 0.8)
	{
		PlayAnim('TSlap001'); 
		PlaySound(Sound 'Swing1');			
	}
	else
	{
		PlayAnim('TStom001');
		PlaySound(Sound 'Stomp2');			
	}
}

Begin:
	//log(class$" Melee Attack");
	if (Target == None)
		Target = Enemy;

	DesiredRotation = Rotation(Target.Location - Location);
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	DesiredSpeed = 0.0; //stop (big mass, so negative accel won't do it)
	Acceleration = vect(0,0,0); //stop
	if (NeedToTurn(Target.Location))
		{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		FinishAnim();
		}
	if (Size(Location - Enemy.Location) > MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('RangedAttack', 'ReadyToAttack'); //FIXME - do for most/all

ReadyToAttack:
	DesiredRotation = Rotation(Target.Location - Location);
	PlayMeleeAttack();
	FinishAnim();
	KeepAttacking();
	Goto('FaceTarget');
}

state RangedAttack
{
ignores SeePlayer, HearNoise, Bump;

Begin:
	if (Target == None)
		Target = Enemy;

	DesiredSpeed = 0.0; //stop (big mass, so negative accel won't do it)
	Acceleration = vect(0,0,0); //stop
	//log(class$" Ranged Attack");
	DesiredRotation = Rotation(Target.Location - Location);
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	DesiredSpeed = 0.0;
	if (NeedToTurn(Target.Location))
		{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		}

	if (Size(Location - Enemy.Location) < MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('MeleeAttack', 'ReadyToAttack'); 

ReadyToAttack:
	DesiredRotation = Rotation(Target.Location - Location);

	FinishAnim();
	////log("Play ranged attack");
	if ((AnimSequence == 'TStom001') || (FRand() < 0.65))
	{
		PlayAnim('TThro001');
		PlaySound(Sound 'Swing1');			
	}
	else
	{
		PlayAnim('TStom001'); 
		PlaySound(Sound 'Stomp2');			
	}
	FinishAnim();
	KeepAttacking(0.7);
	Goto('FaceTarget');
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      bStomp=False
      realSpeed=+00000.000000
      Health=250
      ArmorClass=ARMOR_Super
      bHasRangedAttack=True
      SightRadius=+04000.000000
      MeleeRange=+00110.000000
      Aggressiveness=+00001.000000
      Visibility=255
      Intelligence=BRAINS_NONE
      GroundSpeed=+00400.000000
      AccelRate=+01000.000000
      JumpZ=-00001.000000
      CombatStyle=+00000.600000
      DrawType=DT_Mesh
      Mesh=Titan
      CollisionRadius=+00115.000000
      CollisionHeight=+00110.000000
      bMeshCurvy=False
      Mass=+02000.000000
      RotationSpeed=30000
   End DefaultProperties
End Class

Begin Class Name=Cow
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Cow.
//=============================================================================
class Cow expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Cow ANIVFILE=..\MODELS\Cow_a.3D DATAFILE=..\MODELS\Cow_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Cow X=0 Y=100 Z=-120 YAW=64

#exec MESH SEQUENCE MESH=Cow SEQ=All    STARTFRAME=0  NUMFRAMES=1
#exec MESH SEQUENCE MESH=Cow SEQ=Still  STARTFRAME=0  NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JCow1 FILE=..\MODELS\Cow.PCX FAMILY=Skins PALETTE=JCow1 

#exec MESHMAP NEW   MESHMAP=Cow MESH=Cow
#exec MESHMAP SCALE MESHMAP=Cow X=0.08 Y=0.08 Z=0.16

#exec MESHMAP SETTEXTURE MESHMAP=Cow NUM=1 TEXTURE=JCow1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Cow
      CollisionRadius=+00045.000000
      CollisionHeight=+00035.000000
   End DefaultProperties
End Class

Begin Class Name=Pupae
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Pupae.
//=============================================================================
class Pupae expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Pupae ANIVFILE=..\MODELS\pupae_a.3D DATAFILE=..\MODELS\pupae_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Pupae X=0 Y=0 Z=0 YAW=64

#exec MESH SEQUENCE MESH=pupae SEQ=All    STARTFRAME=0  NUMFRAMES=1
#exec MESH SEQUENCE MESH=pupae SEQ=Still  STARTFRAME=0  NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JPupae1 FILE=..\MODELS\pupae.PCX FAMILY=Skins PALETTE=Jpupae1 

#exec MESHMAP NEW   MESHMAP=pupae MESH=pupae 
#exec MESHMAP SCALE MESHMAP=pupae X=0.03 Y=0.03 Z=0.06

#exec MESHMAP SETTEXTURE MESHMAP=pupae NUM=1 TEXTURE=Jpupae1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Pupae
      CollisionRadius=+00028.000000
      CollisionHeight=+00009.000000
   End DefaultProperties
End Class

Begin Class Name=Mercenary
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Mercenary
//=============================================================================
class Mercenary expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Merc ANIVFILE=..\MODELS\Merc_a.3D DATAFILE=..\MODELS\Merc_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Merc X=0 Y=90 Z=-80 YAW=64

#exec MESH SEQUENCE MESH=Merc SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=Merc SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JMerc1 FILE=..\MODELS\Mercenar.PCX FAMILY=Skins PALETTE=JMerc1 

#exec MESHMAP NEW   MESHMAP=Merc MESH=Merc 
#exec MESHMAP SCALE MESHMAP=Merc X=0.045 Y=0.045 Z=0.09

#exec MESHMAP SETTEXTURE MESHMAP=Merc NUM=1 TEXTURE=JMerc1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Merc
      CollisionRadius=+00030.000000
      CollisionHeight=+00039.000000
   End DefaultProperties
End Class

Begin Class Name=Queen
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Queen.
//=============================================================================
class Queen expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Queen ANIVFILE=..\MODELS\queen_a.3D DATAFILE=..\MODELS\queen_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Queen X=0 Y=-400 Z=-50 YAW=64

#exec MESH SEQUENCE MESH=queen SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=queen SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JQueen1 FILE=..\MODELS\queen.PCX FAMILY=Skins PALETTE=Jqueen1 

#exec MESHMAP NEW   MESHMAP=queen MESH=queen 
#exec MESHMAP SCALE MESHMAP=queen X=0.15 Y=0.15 Z=0.3

#exec MESHMAP SETTEXTURE MESHMAP=queen NUM=1 TEXTURE=Jqueen1 ; Apply textures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Queen
      CollisionRadius=+00082.000000
      CollisionHeight=+00097.000000
   End DefaultProperties
End Class

Begin Class Name=Squid
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Squid.
//=============================================================================
class Squid expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Squid ANIVFILE=..\MODELS\squid_a.3D DATAFILE=..\MODELS\squid_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Squid X=0 Y=100 Z=0 YAW=128 ROLL=-64 

#exec MESH SEQUENCE MESH=squid SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=squid SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JSquid1 FILE=..\MODELS\squid.PCX FAMILY=Skins PALETTE=Jsquid1 

#exec MESHMAP NEW   MESHMAP=Squid MESH=squid 
#exec MESHMAP SCALE MESHMAP=Squid X=0.1 Y=0.1 Z=0.2

#exec MESHMAP SETTEXTURE MESHMAP=squid NUM=1 TEXTURE=Jsquid1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Squid
      CollisionRadius=+00030.000000
      CollisionHeight=+00038.000000
   End DefaultProperties
End Class

Begin Class Name=Slith
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Slith.
//=============================================================================
class Slith expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Slith ANIVFILE=..\MODELS\slith_a.3D DATAFILE=..\MODELS\slith_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Slith X=0 Y=-300 Z=-40 YAW=64

#exec MESH SEQUENCE MESH=slith SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=slith SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JSlith1 FILE=..\MODELS\slith.PCX FAMILY=Skins PALETTE=Jslith1 

#exec MESHMAP NEW   MESHMAP=slith MESH=slith 
#exec MESHMAP SCALE MESHMAP=slith X=0.04 Y=0.04 Z=0.08

#exec MESHMAP SETTEXTURE MESHMAP=slith NUM=1 TEXTURE=Jslith1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Slith
      CollisionHeight=+00024.000000
   End DefaultProperties
End Class

Begin Class Name=Warlord
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Warlord.
//=============================================================================
class Warlord expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Warlord ANIVFILE=..\MODELS\warlor_a.3D DATAFILE=..\MODELS\warlor_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Warlord X=0 Y=00 Z=0 YAW=64

#exec MESH SEQUENCE MESH=warlord SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=warlord SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JWarlord1 FILE=..\MODELS\warlord.PCX FAMILY=Skins PALETTE=Jwarlord1 FLAGS=2

#exec MESHMAP NEW   MESHMAP=Warlord MESH=warlord 
#exec MESHMAP SCALE MESHMAP=Warlord X=0.09 Y=0.09 Z=0.18

#exec MESHMAP SETTEXTURE MESHMAP=warlord NUM=1 TEXTURE=Jwarlord1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Warlord
      CollisionRadius=+00052.000000
      CollisionHeight=+00078.000000
   End DefaultProperties
End Class

Begin Class Name=Nali
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Nali.
//=============================================================================
class Nali expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Nali ANIVFILE=..\MODELS\nali_a.3D DATAFILE=..\MODELS\nali_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Nali X=0 Y=00 Z=0 YAW=64

#exec MESH SEQUENCE MESH=nali SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=nali SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JNali1 FILE=..\MODELS\nali.PCX FAMILY=Skins PALETTE=Jnali1 

#exec MESHMAP NEW   MESHMAP=nali MESH=nali 
#exec MESHMAP SCALE MESHMAP=nali X=0.04 Y=0.04 Z=0.08

#exec MESHMAP SETTEXTURE MESHMAP=nali NUM=1 TEXTURE=Jnali1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Nali
      CollisionRadius=+00018.000000
      CollisionHeight=+00040.000000
   End DefaultProperties
End Class

Begin Class Name=Turret
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Turret.
//=============================================================================
class Turret expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Turret ANIVFILE=..\MODELS\turret_a.3D DATAFILE=..\MODELS\turret_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Turret X=-50 Y=0 Z=-10 YAW=0

#exec MESH SEQUENCE MESH=turret SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=turret SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JTurret1 FILE=..\MODELS\turret.PCX FAMILY=Skins PALETTE=Jturret1 

#exec MESHMAP NEW   MESHMAP=turret MESH=turret 
#exec MESHMAP SCALE MESHMAP=turret X=0.05 Y=0.05 Z=0.1

#exec MESHMAP SETTEXTURE MESHMAP=turret NUM=1 TEXTURE=Jturret1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Turret
      CollisionRadius=+00035.000000
      CollisionHeight=+00012.000000
   End DefaultProperties
End Class

Begin Class Name=Hawk
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// hawk.
//=============================================================================
class Hawk expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Hawk ANIVFILE=..\MODELS\hawk_a.3D DATAFILE=..\MODELS\hawk_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Hawk X=0 Y=0 Z=0 YAW=64

#exec MESH SEQUENCE MESH=Hawk SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=Hawk SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JHawk1 FILE=..\MODELS\hawk.PCX FAMILY=Skins PALETTE=Jhawk1 FLAGS=2

#exec MESHMAP NEW   MESHMAP=hawk MESH=hawk 
#exec MESHMAP SCALE MESHMAP=hawk X=0.1 Y=0.1 Z=0.2

#exec MESHMAP SETTEXTURE MESHMAP=hawk NUM=1 TEXTURE=Jhawk1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Hawk
      CollisionRadius=+00052.000000
      CollisionHeight=+00018.000000
   End DefaultProperties
End Class

Begin Class Name=Fly
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Fly.
//=============================================================================
class Fly expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Fly ANIVFILE=..\MODELS\fly_a.3D DATAFILE=..\MODELS\fly_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Fly X=0 Y=-450 Z=0 YAW=64

#exec MESH SEQUENCE MESH=Fly SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=Fly SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JFly1 FILE=..\MODELS\fly.PCX FAMILY=Skins PALETTE=Jfly1 FLAGS=2

#exec MESHMAP NEW   MESHMAP=fly MESH=fly 
#exec MESHMAP SCALE MESHMAP=fly X=0.02 Y=0.02 Z=0.04

#exec MESHMAP SETTEXTURE MESHMAP=fly NUM=1 TEXTURE=Jfly1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Fly
      CollisionRadius=+00016.000000
      CollisionHeight=+00008.000000
   End DefaultProperties
End Class

Begin Class Name=Blob
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Blob
//=============================================================================
class Blob expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Blob ANIVFILE=..\MODELS\blob_a.3D DATAFILE=..\MODELS\blob_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Blob X=0 Y=-100 Z=-230 YAW=64

#exec MESH SEQUENCE MESH=Blob SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=Blob SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JBlob1 FILE=..\MODELS\blob.PCX FAMILY=Skins PALETTE=Jblob1 

#exec MESHMAP NEW   MESHMAP=Blob MESH=blob
#exec MESHMAP SCALE MESHMAP=Blob X=0.07 Y=0.07 Z=0.14

#exec MESHMAP SETTEXTURE MESHMAP=blob NUM=1 TEXTURE=Jblob1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Blob
      CollisionRadius=+00037.000000
      CollisionHeight=+00009.000000
   End DefaultProperties
End Class

Begin Class Name=Firefly
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Firefly.
//=============================================================================
class Firefly expands ScriptedPawn
	package(UnGame);

#exec MESH IMPORT MESH=Firefly ANIVFILE=..\MODELS\firef_a.3D DATAFILE=..\MODELS\firef_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Firefly X=0 Y=00 Z=0 YAW=64

#exec MESH SEQUENCE MESH=Firefly SEQ=All    STARTFRAME=0   NUMFRAMES=1
#exec MESH SEQUENCE MESH=Firefly SEQ=Still  STARTFRAME=0   NUMFRAMES=1


#exec TEXTURE IMPORT NAME=JFirefly1 FILE=..\MODELS\firefly.PCX FAMILY=Skins PALETTE=Jfirefly1 FLAGS=2

#exec MESHMAP NEW   MESHMAP=Firefly MESH=firefly
#exec MESHMAP SCALE MESHMAP=Firefly X=0.005 Y=0.005 Z=0.01

#exec MESHMAP SETTEXTURE MESHMAP=firefly NUM=1 TEXTURE=Jfirefly1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      DrawType=DT_Mesh
      Mesh=Firefly
      CollisionRadius=+00002.000000
      CollisionHeight=+00001.000000
   End DefaultProperties
End Class

Begin Class Name=FireflySwarm
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// FireflySwarm.
//=============================================================================
class FireflySwarm expands ScriptedPawn
	package(UnGame);

var() byte swarmsize; //number of fireflies in swarm

//FIXME add stasis mode

auto state wandering
{
function addflies()
	{
	local actor newfly;
	local int num;
	num = swarmsize;
	while (num > 0)
		{
		num -= 1;
		newfly = spawn(class 'firefly',None,'', Location + VRand() * CollisionRadius);
		newfly.setowner(self);
		}
	}
	
function timer ()
	{
	gotostate('wandering','newdir');
	}

Begin:
	addflies();

Newdir:
	MoveTo(300 * VRand());
}		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      swarmsize=0
   End DefaultProperties
End Class

Begin Class Name=SkaarjWarrior
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// Skaarj.
//=============================================================================
class SkaarjWarrior expands ScriptedPawn
	package(UnGame);
	
#exec MESH IMPORT MESH=Skaarjw ANIVFILE=..\MODELS\Skaarj_a.3D DATAFILE=..\MODELS\Skaarj_d.3D X=0 Y=0 Z=0
#exec MESH ORIGIN MESH=Skaarjw X=0 Y=0 Z=00 YAW=64

#exec MESH SEQUENCE MESH=Skaarjw SEQ=All  STARTFRAME=0  NUMFRAMES=475

#exec MESH SEQUENCE MESH=Skaarjw SEQ=Squat        STARTFRAME=1   NUMFRAMES=40
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Blade        STARTFRAME=39  NUMFRAMES=35
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Claw         STARTFRAME=74  NUMFRAMES=19
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Death        STARTFRAME=93  NUMFRAMES=44
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Fighter      STARTFRAME=137 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Headup       STARTFRAME=138 NUMFRAMES=20
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Firing       STARTFRAME=159 NUMFRAMES=19
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Looking      STARTFRAME=179 NUMFRAMES=44
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Jog          STARTFRAME=223 NUMFRAMES=20
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Lunge        STARTFRAME=243 NUMFRAMES=34
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Spin         STARTFRAME=277 NUMFRAMES=19
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T1           STARTFRAME=296 NUMFRAMES=4
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T2           STARTFRAME=300 NUMFRAMES=9
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T3           STARTFRAME=309 NUMFRAMES=4
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T4           STARTFRAME=313 NUMFRAMES=4
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T5           STARTFRAME=317 NUMFRAMES=14
#exec MESH SEQUENCE MESH=Skaarjw SEQ=T6           STARTFRAME=331 NUMFRAMES=4
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Breath       STARTFRAME=335 NUMFRAMES=30
#exec MESH SEQUENCE MESH=Skaarjw SEQ=HairFlip     STARTFRAME=365 NUMFRAMES=20
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Jump         STARTFRAME=385 NUMFRAMES=9
#exec MESH SEQUENCE MESH=Skaarjw SEQ=InAir        STARTFRAME=394 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Landed       STARTFRAME=397 NUMFRAMES=3
#exec MESH SEQUENCE MESH=Skaarjw SEQ=Walk         STARTFRAME=400 NUMFRAMES=15
#exec MESH SEQUENCE MESH=Skaarjw SEQ=LeftHit      STARTFRAME=415 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=RightHit     STARTFRAME=416 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=HeadHit      STARTFRAME=417 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=GutHit       STARTFRAME=418 NUMFRAMES=1
#exec MESH SEQUENCE MESH=Skaarjw SEQ=StrafeLeft   STARTFRAME=419 NUMFRAMES=28
#exec MESH SEQUENCE MESH=Skaarjw SEQ=StrafeRight  STARTFRAME=447 NUMFRAMES=28

#exec TEXTURE IMPORT NAME=Skaarjw1 FILE=..\MODELS\Skaarj.PCX FAMILY=Skins PALETTE=Skaarjw1 

#exec MESHMAP NEW   MESHMAP=Skaarjw MESH=Skaarjw 
#exec MESHMAP SCALE MESHMAP=Skaarjw X=0.09 Y=0.09 Z=0.18

#exec MESHMAP SETTEXTURE MESHMAP=Skaarjw NUM=1 TEXTURE=Skaarjw1

#exec MESH NOTIFY MESH=Skaarjw SEQ=Spin TIME=0.5 FUNCTION=SpinDamageTarget
#exec MESH NOTIFY MESH=Skaarjw SEQ=Claw TIME=0.24 FUNCTION=ClawDamageTarget
#exec MESH NOTIFY MESH=Skaarjw SEQ=Claw TIME=0.76 FUNCTION=ClawDamageTarget

#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\1aprehensive.UFX" NAME="aprehensive" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\bladeclose.UFX" NAME="bladeclose" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\bladeopen.UFX" NAME="bladeopen" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\breath1.UFX" NAME="breath1" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\breath2.UFX" NAME="breath2" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\death1.UFX" NAME="death1" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\challenge.UFX" NAME="challenge" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\fire3.UFX" NAME="fire3" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\injur1.UFX" NAME="injur1" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\injur2.UFX" NAME="injur2" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\landthump.UFX" NAME="landthump" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\nearby.UFX" NAME="nearby" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\yell2.UFX" NAME="yell2" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\slice1.UFX" NAME="slice1" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\swoosh2.UFX" NAME="swoosh2" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\swoosh3.UFX" NAME="swoosh3" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\swoosh5.UFX" NAME="swoosh5" FAMILY="Skaarj"
#exec AUDIO IMPORT FILE="..\Sounds\Skaarj\call6.UFX" NAME="call6" FAMILY="Skaarj"


//-----------------------------------------------------------------------------
// Skaarj variables.

// Attack damage.
var() byte
	LungeDamage,	// Basic damage done by lunge.
	SpinDamage,		// Basic damage done by spin.
	ClawDamage,		// Basic damage done by each claw.
	ShootDamage;	// Basic damage caused by shooting.

var bool AttackSuccess;
//Skaarj animations
function PlayWaiting()
	{
	local float decision;
	local float animspeed;
	
	if (NextAnim == 'TweenToSquat')
		{
		TweenAnim('Squat', 0.5);
		Enable('AnimEnd');
		NextAnim = 'Squat';
		PlaySound(Sound 'Nearby');			
		}
	else if (NextAnim == 'TweenToBreath')
		{
		TweenAnim('Breath', 0.5);
		Enable('AnimEnd');
		NextAnim = 'Breath';
		}
	else
		{		
		
		decision = FRand();
		if (!bool(NextAnim)) //pick first waiting animation
			NextAnim = 'Squat';

		if (NextAnim == 'Breath')
			animspeed = 0.2 + 0.5 * FRand();
		else
			animspeed = 0.4 + 0.6 * FRand(); //vary speed

		LoopAnim(NextAnim, animspeed);
		
		////log("Next skaarj waiting anim is "$nextanim);
		if (NextAnim == 'Breath')
			{
			Alertness = 0.2;
			if (decision < 0.1)
				NextAnim = 'HairFlip';
			else if (decision < 0.15)
				NextAnim = 'TweenToSquat';
			}
		else if (NextAnim == 'Squat')
			{
			Alertness = -0.5;
			if (decision < 0.25) 
			{
				NextAnim = 'Blade';
				PlaySound(Sound 'BladeOpen');				
			}
			else if (decision < 0.5) 
			{
				NextAnim = 'Headup';
				PlaySound(Sound 'Nearby');					
			}
			else if (decision < 0.6)
				NextAnim = 'TweenToBreath';
	 		}
		else if (NextAnim == 'Looking')
			{
			PlaySound(Sound 'Nearby');			
			Alertness = 1.0;
			if (decision < 0.65)
				NextAnim = 'Squat';
			else if (decision < 0.8)
				NextAnim = 'TweenToBreath';
			}
		else if (NextAnim == 'Headup')
			{
			if (decision < 0.1)
				NextAnim = 'TweenToBreath';
			else	
				NextAnim = 'Looking';
			Enable('AnimEnd');
			Alertness = 0.0;
			}
		else if (NextAnim == 'Blade')
			{
			Alertness = -0.5;
			if (decision < 0.88) 
				NextAnim = 'Squat';
			}
		else if (NextAnim == 'HairFlip')
			{
			Alertness = -0.5;
			NextAnim = 'Breath';
			Enable('AnimEnd');  //don't allow to repeat
			}
		}
	}

function PlayPatrolStop()
	{
	if (FRand() < 0.05)
		{
		Alertness = -0.5;
		PlayAnim('HairFlip', 0.4 + 0.3 * FRand());
		Enable('AnimEnd');
		}
	else
		{
		Alertness = 0.2;	
		LoopAnim('Breath', 0.4 + 0.6 * FRand());
		PlaySound(Sound 'Yell2');
		}
	}

function PlayWaitingGuard()
	{
	if (FRand() < 0.05)
		{
		Alertness = -0.5;
		PlayAnim('HairFlip', 0.4 + 0.3 * FRand());
		Enable('AnimEnd');
		}
	else
		{
		Alertness = 0.2;	
		LoopAnim('Breath', 0.4 + 0.6 * FRand());
		}
	}

function PlayWaitingAmbush()
	{
	Alertness = 1.0;
	LoopAnim('Breath', 0.4 + 0.6 * FRand());
	}

function PlayFighter()
	{
	LoopAnim('Fighter');
	}

function TweenToFighter(float tweentime)
{
	TweenAnim('Fighter', tweentime);
}

function TweenToRunning(float tweentime)
{
	TweenAnim('Jog', tweentime);
}

function TweenToWalking(float tweentime)
{
	TweenAnim('Walk', tweentime);
}

function TweenToWaiting(float tweentime)
{
	TweenAnim('Squat', tweentime);
}

function TweenToPatrolStop(float tweentime)
{
	TweenAnim('Breath', tweentime);
}

function PlayRunning()
{
	LoopAnim('Jog', -1.0/GroundSpeed,true, 0.4);
}

function PlayWalking()
{
	LoopAnim('Walk', -1.0/GroundSpeed,true, 0.4);
}

function PlayStrafeLeft()
{
	LoopAnim('StrafeLeft', -2.5/GroundSpeed,true, 0.4);
}

function PlayStrafeRight()
{
	LoopAnim('StrafeRight', -2.5/GroundSpeed,true, 0.4);
}

function PlayThreatening()
{
	local float decision;
	decision = FRand();
	
	if (!bool(NextAnim)) //pick first waiting animation
		NextAnim = 'Breath';
	
	if (NextAnim == 'Breath')
		{
		LoopAnim('Breath', 0.4 + 0.6 * FRand());
		PlaySound(Sound 'Breath2');
		if (FRand() < 0.2)
			NextAnim = 'TweenToThreat';
		}
	else if (NextAnim == 'TweenToThreat')
		{
		TweenAnim('Fighter', 0.2);
		NextAnim = 'Threaten';
		}
	else if (NextAnim == 'Threaten')
		{
		PlayAnim('Claw');
		PlaySound(Sound 'BladeOpen');		
		NextAnim = 'TweenToBreath';
		}
	else if (NextAnim == 'TweenToBreath')
		{
		TweenAnim('Breath', 0.2);
		NextAnim = 'Breath';
		}
}

function PlayTurning()
{
	LoopAnim('Breath');
	PlaySound(Sound 'Breath1');	
}

function PlayDying()
{
	PlayAnim('Death');
	PlaySound(Sound 'Death1');	
}

function PlayTakeHit(float tweentime, vector HitLoc)
{
	local vector X,Y,Z, HitVec;
	local float dotp;
	GetAxes(Rotation,X,Y,Z);
	HitVec = Normal(HitLoc - Location);
	//FIXME - move this function to damage?
	//log ("Play Take Hit");
	dotp = HitVec dot X;
	//log ("yaw test = "$dotp);
	if (dotp > 0.8) //then hit in front
		{
		PlaySound(Sound 'Injur1');			
		dotp = HitVec dot Z;
		//log ("pitch test = "$dotp);
		if (dotp > 0.4)
			TweenAnim('HeadHit', tweentime);
		else
			TweenAnim('GutHit', tweentime);
		}
	else if (dotp < -0.8) // then hit in back
		{
		PlaySound(Sound 'Injur2');			
		dotp = HitVec dot Z;
		//log ("pitch test = "$dotp);
		if (dotp > 0.4)
			TweenAnim('GutHit', tweentime);
		else
			TweenAnim('HeadHit', tweentime);
		}
	else
		{
		PlaySound(Sound 'Injur1');			
		dotp = HitVec dot Y;
		//log ("left/right test = "$dotp);
		if (dotp > 0.0)
			TweenAnim('LeftHit', tweentime);
		else
			TweenAnim('RightHit', tweentime);
		}
	
}

function PlayBigHit()
{
	local vector HitLoc;
	HitLoc = Location;
	if (FRand() > 0.5)
	HitLoc.Z += EyeHeight;
	PlayTakeHit(0.2, HitLoc);
}

function PlayJump(float jumpTime)
{
	PlayAnim('Jump', jumpTime); //FIXME - tween to jump (find a good frame)
	PlaySound(Sound 'Yell2');		
}

function PlayInAir()
{
	////log("in the air");
	//TweenAnim('InAir', 0.2);
}

function PlayLanded()
{
	TweenAnim('Landed', 0.2);
	PlaySound(Sound 'LandThump');		
}

final function SpawnTwoShots()
{
	local Projectile Proj;
	local rotation FireRotation;
	local vector X,Y,Z, projStart;
	local float aimerr;
	local bool goodRot;
	GetAxes(Rotation,X,Y,Z);

	////log("Skaarj shoots!");
	aimerr = Rand(400) - 200;
	projStart = Location + 1.2 * CollisionRadius * X + 0.5 * CollisionRadius * Y;
	Proj = spawn(class 'SkaarjProjectile',self,'',projStart);
	PlaySound(Sound 'Fire3');		
	if( Proj != None )
		{
		FireRotation = AdjustAim(proj.speed, projStart, 0, true);  
		FireRotation.Yaw = FireRotation.Yaw + aimerr; 
		Proj.SetRotation(FireRotation);
		goodRot = true;
		} 
	else
		goodRot = false;
		
	projStart = Location + 1.2 * CollisionRadius * X - 0.5 * CollisionRadius * Y;
	Proj = spawn(class 'SkaarjProjectile',self,'',projStart);
	PlaySound(Sound 'Fire3');		
	if( Proj != None )
		{
		if (!goodRot)
			{
			FireRotation = AdjustAim(proj.speed, projStart, 0, true);  
			FireRotation.Yaw = FireRotation.Yaw + aimerr; 
			}
		FireRotation.Yaw = FireRotation.Yaw + aimerr + Rand(300) - 150;
		Proj.SetRotation(FireRotation);
		}
}

//Also - need to be able to acquire enemies during victory dance
//(at least if shot)
function PlayVictoryDance()
{
	PlayAnim('HairFlip', 0.6);
	PlaySound(Sound 'Challenge');		
}
	
state MeleeAttack
{
ignores SeePlayer, HearNoise, Bump;

function PlayTakeHit(float tweentime, vector HitLoc)
{
	if (AnimSequence != 'Spin')
		CallGlobal.PlayTakeHit(tweentime, HitLoc);
}


final function SpinDamageTarget()
{
	DamageTarget(30, (20000.0 * Normal(Target.Location - Location)));
	PlaySound(Sound 'Slice1');		
}

final function ClawDamageTarget()
{
	If (Size(Target.Location - Location) <= 
		(CollisionRadius + Target.CollisionRadius + CollisionRadius))
		DamageTarget(20, (7000.0 * Normal(Target.Location - Location)));
	PlaySound(Sound 'Slice1');			
}

	
final function PlayMeleeAttack()
{
	local int hitdamage;
	local float TargetDist;

	AttackSuccess = false;
	////log("Start Melee Attack");
	if (FRand() < 0.5)
		{
		Acceleration = AccelRate * Normal(Target.Location - Location);
 		PlayAnim('Spin');
		PlaySound(Sound 'Swoosh3');	 		
 		}
	else
 		PlayAnim('Claw'); 
 		if (FRand() < 0.5) PlaySound(Sound 'Swoosh2');	 		
 		else PlaySound(Sound 'Swoosh5');	
 }

Begin:
	//log(class$" Melee Attack");
	if (Target == None)
		Target = Enemy;
	DesiredRotation = Rotation(Target.Location - Location);
	TweenToFighter(0.2);
	FinishAnim();
	
FaceTarget:
	Acceleration = vect(0,0,0); //stop
	if (NeedToTurn(Target.Location))
		{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		FinishAnim();
		}

ReadyToAttack:
	if (Size(Location - Enemy.Location) > MeleeRange + CollisionRadius + Target.CollisionRadius)
		GotoState('RangedAttack', 'ReadyToAttack'); //FIXME - do for most/all
	DesiredRotation = Rotation(Target.Location - Location);
	PlayMeleeAttack();
	FinishAnim();
	KeepAttacking();
	Goto('FaceTarget');
}

state RangedAttack
{
ignores SeePlayer, HearNoise;

function PlayTakeHit(float tweentime, vector HitLoc)
{
	if (AnimSequence != 'Lunge')
		CallGlobal.PlayTakeHit(tweentime, HitLoc);
}

function Bump (Actor Other)
{
	local vector momentum;

	if (AnimFrame > 0.5)
		Disable('Bump');
			
	if (!AttackSuccess && (AnimFrame >= 0.3) && (AnimFrame <= 0.5))
		If (DamageTarget(30, (40000.0 * Normal(Velocity))))
			{
			AttackSuccess = true;
			Disable('Bump');
			}
	
	if (!AttackSuccess) //always add momentum
		{
		momentum = 30000.0 * Normal(Target.Location - Location);
		if (Other.Physics == PHYS_Walking)
			{
			Other.Physics = PHYS_Falling;
			momentum.Z = 1.0;
			}
			
		Other.Velocity += momentum/Other.Mass; 
		}
}

function bool DamageTarget(int hitdamage, vector pushdir)
	{
	local vector HitLocation, HitNormal, TargetPoint;
	local float TargetDist;
	local actor HitActor;
	local bool result;
	
	result = false;
	TargetDist = Size(Target.Location - Location);
	If (TargetDist <= (MeleeRange + Target.CollisionRadius + CollisionRadius)) //still in melee range
		{
		TargetPoint = Location + TargetDist * vector(Rotation); 
		TargetPoint.Z = FMin(TargetPoint.Z, Target.Location.Z + Target.CollisionHeight);
		TargetPoint.Z = FMax(TargetPoint.Z, Target.Location.Z - Target.CollisionHeight);
		HitActor = Trace(HitLocation, HitNormal, TargetPoint, Location, true);
		If (HitActor == Target)
			{	
			Target.Damage(hitdamage, Self,HitLocation, pushdir);
			result = true;
			}
		}
	}
		
final function LungeDamageTarget()
{
	local vector momentum;
	momentum = Normal(Velocity);
	momentum.Z = 1.0;
	momentum = 40000.0 * momentum;
	If (DamageTarget(35, momentum))
		{
		AttackSuccess = true;
		disable('Bump');
		}
}

Begin:
	if (Target == None)
		Target = Enemy;
	Disable('Bump');
	Acceleration = vect(0,0,0); //stop
	//log(class$" Ranged Attack");
	TweenToFighter(0.2);
	FinishAnim();

FaceTarget:
	if (NeedToTurn(Target.Location))
	{
		PlayTurning();
		TurnToward(Target);
		TweenToFighter(0.2);
		FinishAnim();
	}
	DesiredRotation = Rotation(Target.Location - Location);
	
ReadyToAttack:
	if (Size(Location - Enemy.Location) < 140 + CollisionRadius + Target.CollisionRadius)
		{
		if (Size(Location - Enemy.Location) < 0.8 * MeleeRange + CollisionRadius + Target.CollisionRadius)
			GotoState('MeleeAttack', 'ReadyToAttack'); //FIXME - do for most/all
 		Velocity = GroundSpeed * Normal(Target.Location - Location); //instant acceleration in that direction 
 		Velocity.Z = JumpZ * FMin(0.8, Size(Target.Location - Location)/140);
 		Physics = PHYS_Falling;
 		Enable('Bump');
 		PlayAnim('Lunge');
 		}
	else
		{
		////log("Play ranged attack");
		PlayAnim('Firing', 1.5); 
		SpawnTwoShots();
		FinishAnim();
		PlayAnim('Firing', 1.0); 
		SpawnTwoShots();
		}
	FinishAnim();
	KeepAttacking(0.15);
	Goto('FaceTarget');
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      LungeDamage=25
      SpinDamage=20
      ClawDamage=20
      ShootDamage=11
      AttackSuccess=False
      ArmorClass=ARMOR_Super
      bHasRangedAttack=True
      bCanStrafe=True
      MeleeRange=+00040.000000
      Aggressiveness=+00000.500000
      Visibility=128
      Intelligence=BRAINS_HUMAN
      GroundSpeed=+00460.000000
      WaterSpeed=+00180.000000
      AccelRate=+00500.000000
      JumpZ=+00260.000000
      MaxStepHeight=+00024.000000
      CombatStyle=+00000.800000
      DrawType=DT_Mesh
      Mesh=Skaarjw
      CollisionRadius=+00035.000000
      CollisionHeight=+00046.000000
      Mass=+00200.000000
      RotationSpeed=50000
   End DefaultProperties
End Class

Begin Class Name=SkaarjDummy
   Begin Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//=============================================================================
// SkaarjDummy.
//=============================================================================
class SkaarjDummy expands SkaarjWarrior;

function bool SetEnemy(pawn Other)
{
}

state DoNothing
{
ignores seeplayer, hearnoise, bump, animend;

function Damage( int Damage, Pawn instigatedBy, Vector hitlocation, 
						Vector momentum)
{
	CallGlobal.Damage(Damage, instigatedBy, hitlocation, momentum);
	if (NextAnim == 'TakeHit')
		GotoState('DoNothing', 'Recover');
}

Recover:
	log("Playing "$AnimSequence);
	FinishAnim();
	log("recover");
	TweenToFighter(0.2);
Begin:
	//log ("Do Nothing");
}

state Dying
{
Begin:
	Health = 100;
	GotoState('DoNothing', 'Recover');
}

auto state Strafe
{
function HitWall(vector HitNormal)
{
	GotoState('Strafe', 'Start');	
	
}

function StartStrafe()
{
	local vector X,Y,Z;
	GetAxes(Rotation,X,Y,Z);
	
	Focus = vect(0,0,0);
	if (count == 0)
		{
		count = 1;
		PlayStrafeLeft();
		Destination = Location + 500 * Y;
		}
	else
		{
		count = 0;
		PlayStrafeRight();
		Destination = Location - 500 * Y;
		}
}		
		
Begin:
	count = 0;
Start:
	StartStrafe();
	StrafeTo(Destination, Focus);
	Goto('Start');
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   End Text
   Begin DefaultProperties
      LungeDamage=0
      SpinDamage=0
      ClawDamage=0
      ShootDamage=0
      ArmorClass=ARMOR_Normal
      MeleeRange=+00080.000000
      Aggressiveness=+00000.000000
      GroundSpeed=+00400.000000
      AccelRate=+00600.000000
      MaxStepHeight=+00030.000000
      CombatStyle=+00000.000000
      CollisionRadius=+00040.000000
      Physics=PHYS_Walking
   End DefaultProperties
End Class

